using System;
using System.Collections.Generic;
using System.Data.SqlTypes;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Numerics;
using System.Speech.Synthesis;
using System.Speech.Recognition;
using System.Speech.AudioFormat;
using System.Threading.Tasks;
using System.Text;

namespace ProjectEularProblems
{
	/// <summary>
	/// This class contains the first one hundred problems from ProjectEuler.Net
	/// </summary>
	public static class Problems
	{

		static void Main( string[] args )
		{

			Stopwatch sp = new Stopwatch();
			sp.Start();
			p065_ConvergentsOfE();
			sp.Stop();
			Console.WriteLine("\nruntime: " + sp.ElapsedMilliseconds / 1000.0 + "s");
			Console.ReadLine();
		}

		/// <summary>
		/// PROBLEM 1.
		/// If we list all the natural numbers below 10 that are multiples of 3 or 5, we get 3, 5, 6 and 9. The sum of these multiples is 23.
		/// Find the sum of all the multiples of 3 and 5 below 1000.
		/// </summary>
		public static void p001_MultiplesOf3and5below1000()
		{
			int sum = 0;
			for ( int i = 0; i < 1000; i++ )
			{
				sum = i % 3 == 0 ? sum + i : i % 5 == 0 ? sum + i : sum;
			}
			Console.WriteLine($"sum of all the multiples of 3 or 5 below 1000 : {sum}");
		}

		/// <summary>
		/// PROBLEM 2.
		/// Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
		/// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
		/// By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
		/// </summary>
		public static void p002_SumOfEvenFibonacciNumbers()
		{
			List<int> Numbers = new List<int> { 1, 1 };

			for ( int i = 2; i <= 100; i++ )
			{
				if ( Numbers[ Numbers.Count - 1 ] < 4000000 )
				{
					Numbers.Add(Numbers[ Numbers.Count - 1 ] + Numbers[ Numbers.Count - 2 ]);
				}
			}

			Numbers.RemoveAt(Numbers.Count - 1);
			int SumOfEvenNums = 0;

			foreach ( int n in Numbers )
			{
				if ( n % 2 == 0 )
				{
					SumOfEvenNums += n;
				}
			}
			Console.WriteLine($"the sum of the even-valued terms : {SumOfEvenNums}");
		}

		/// <summary>
		/// PROBLEM 3. 
		/// The largest prime factor of 600 851 475 143.
		/// </summary>
		public static void p003_LargestPrimeFactor()
		{
			for ( Int64 i = 10000; ; i-- )
			{
				Int64 res = 600851475143 % i;
				if ( res == 0 )
				{
					Console.WriteLine(i);
					break;
				}
			}
		}

		/// <summary>
		/// PROBLEM 4.
		/// 
		/// </summary>
		public static int p004_HighestPalindrome()
		{
			int i;
			List<int> PalindromNums = new List<int>();
			for ( int k = 999; k >= 100; k-- )
			{
				for ( int j = 999; j >= 100; j-- )
				{
					i = k * j;
					string s = i.ToString();
					if ( s[ s.Length - 1 ] == s[ 0 ] && s[ s.Length - 2 ] == s[ 1 ] && s[ s.Length - 3 ] == s[ 2 ] )
					{
						PalindromNums.Add(i);
					}
				}
			}

			int BiggestPalindrom = PalindromNums.Max();
			return BiggestPalindrom;
		}

		/// <summary>
		/// PROBLEM 5.
		/// 
		/// </summary>
		public static int p005_SmallestMultipleBy1_20()
		{
			int x = 10;
			while ( true )
			{

				if ( x % 1 == 0 &&
					x % 2 == 0 &&
					x % 3 == 0 &&
					x % 4 == 0 &&
					x % 5 == 0 &&
					x % 6 == 0 &&
					x % 7 == 0 &&
					x % 8 == 0 &&
					x % 9 == 0 &&
					x % 10 == 0 &&
					x % 11 == 0 &&
					x % 12 == 0 &&
					x % 13 == 0 &&
					x % 14 == 0 &&
					x % 15 == 0 &&
					x % 16 == 0 &&
					x % 17 == 0 &&
					x % 18 == 0 &&
					x % 19 == 0 &&
					x % 20 == 0 )
				{
					return ( x );
				}
				x++;
			}
		}

		/// <summary>
		/// PROBLEM 6.
		/// 
		/// </summary>
		/// <returns></returns>
		public static int p006_SumSquareDifference()
		{
			int x = 0;
			for ( int i = 0; i <= 100; i++ )
			{
				x += i;
			}
			x *= x;

			int y = 0;
			for ( int i = 0; i <= 100; i++ )
			{
				int k = i * i;
				y += k;
			}
			return x - y;
		}

		/// <summary>
		/// PROBLEM 7.
		/// The 1 001st prime number.
		/// </summary>
		public static void p007_10001st_Prime()
		{
			int c = 2;

			for ( int i = 5; ; i++ )
			{
				int less = i / 2;
				for ( int j = 2; j <= less; j++ )
				{
					if ( i % j == 0 )
					{
						break;
					}
					else if ( j == less )
					{
						c++;
					}
				}
				if ( c == 10001 )
				{
					Console.WriteLine(i);
					break;
				}
			}
		}

		/// <summary>
		/// PROBLEM 8.
		/// 
		/// </summary>
		public static void p008_LargestProductInASeriesOf1000Numbers()
		{

			List<Int64> AdjacentNums = new List<Int64>();
			List<Int64> Products = new List<Int64>();
			List<Int64> Series = new List<Int64>() {7,3,1,6,7,1,7,6,5,3,1,3,3,0,6,2,4,9,1,9,2,2,5,1,1,9,6,7,4,4,2,6,5,7,4,7,4,2,3,5,5,3,4,9,1,9,4,9,3,4,
												9,6,9,8,3,5,2,0,3,1,2,7,7,4,5,0,6,3,2,6,2,3,9,5,7,8,3,1,8,0,1,6,9,8,4,8,0,1,8,6,9,4,7,8,8,5,1,8,4,3,
												8,5,8,6,1,5,6,0,7,8,9,1,1,2,9,4,9,4,9,5,4,5,9,5,0,1,7,3,7,9,5,8,3,3,1,9,5,2,8,5,3,2,0,8,8,0,5,5,1,1,
												1,2,5,4,0,6,9,8,7,4,7,1,5,8,5,2,3,8,6,3,0,5,0,7,1,5,6,9,3,2,9,0,9,6,3,2,9,5,2,2,7,4,4,3,0,4,3,5,5,7,
												6,6,8,9,6,6,4,8,9,5,0,4,4,5,2,4,4,5,2,3,1,6,1,7,3,1,8,5,6,4,0,3,0,9,8,7,1,1,1,2,1,7,2,2,3,8,3,1,1,3,
												6,2,2,2,9,8,9,3,4,2,3,3,8,0,3,0,8,1,3,5,3,3,6,2,7,6,6,1,4,2,8,2,8,0,6,4,4,4,4,8,6,6,4,5,2,3,8,7,4,9,
												3,0,3,5,8,9,0,7,2,9,6,2,9,0,4,9,1,5,6,0,4,4,0,7,7,2,3,9,0,7,1,3,8,1,0,5,1,5,8,5,9,3,0,7,9,6,0,8,6,6,
												7,0,1,7,2,4,2,7,1,2,1,8,8,3,9,9,8,7,9,7,9,0,8,7,9,2,2,7,4,9,2,1,9,0,1,6,9,9,7,2,0,8,8,8,0,9,3,7,7,6,
												6,5,7,2,7,3,3,3,0,0,1,0,5,3,3,6,7,8,8,1,2,2,0,2,3,5,4,2,1,8,0,9,7,5,1,2,5,4,5,4,0,5,9,4,7,5,2,2,4,3,
												5,2,5,8,4,9,0,7,7,1,1,6,7,0,5,5,6,0,1,3,6,0,4,8,3,9,5,8,6,4,4,6,7,0,6,3,2,4,4,1,5,7,2,2,1,5,5,3,9,7,
												5,3,6,9,7,8,1,7,9,7,7,8,4,6,1,7,4,0,6,4,9,5,5,1,4,9,2,9,0,8,6,2,5,6,9,3,2,1,9,7,8,4,6,8,6,2,2,4,8,2,
												8,3,9,7,2,2,4,1,3,7,5,6,5,7,0,5,6,0,5,7,4,9,0,2,6,1,4,0,7,9,7,2,9,6,8,6,5,2,4,1,4,5,3,5,1,0,0,4,7,4,
												8,2,1,6,6,3,7,0,4,8,4,4,0,3,1,9,9,8,9,0,0,0,8,8,9,5,2,4,3,4,5,0,6,5,8,5,4,1,2,2,7,5,8,8,6,6,6,8,8,1,
												1,6,4,2,7,1,7,1,4,7,9,9,2,4,4,4,2,9,2,8,2,3,0,8,6,3,4,6,5,6,7,4,8,1,3,9,1,9,1,2,3,1,6,2,8,2,4,5,8,6,
												1,7,8,6,6,4,5,8,3,5,9,1,2,4,5,6,6,5,2,9,4,7,6,5,4,5,6,8,2,8,4,8,9,1,2,8,8,3,1,4,2,6,0,7,6,9,0,0,4,2,
												2,4,2,1,9,0,2,2,6,7,1,0,5,5,6,2,6,3,2,1,1,1,1,1,0,9,3,7,0,5,4,4,2,1,7,5,0,6,9,4,1,6,5,8,9,6,0,4,0,8,
												0,7,1,9,8,4,0,3,8,5,0,9,6,2,4,5,5,4,4,4,3,6,2,9,8,1,2,3,0,9,8,7,8,7,9,9,2,7,2,4,4,2,8,4,9,0,9,1,8,8,
												8,4,5,8,0,1,5,6,1,6,6,0,9,7,9,1,9,1,3,3,8,7,5,4,9,9,2,0,0,5,2,4,0,6,3,6,8,9,9,1,2,5,6,0,7,1,7,6,0,6,
												0,5,8,8,6,1,1,6,4,6,7,1,0,9,4,0,5,0,7,7,5,4,1,0,0,2,2,5,6,9,8,3,1,5,5,2,0,0,0,5,5,9,3,5,7,2,9,7,2,5,
												7,1,6,3,6,2,6,9,5,6,1,8,8,2,6,7,0,4,2,8,2,5,2,4,8,3,6,0,0,8,2,3,2,5,7,5,3,0,4,2,0,7,5,2,9,6,3,4,5,0 };

			for ( int i = 0; i < Series.Count - 12; i++ )
			{
				Int64 Product = Series[ i ] *
							  Series[ i + 1 ] *
							  Series[ i + 2 ] *
							  Series[ i + 3 ] *
							  Series[ i + 4 ] *
							  Series[ i + 5 ] *
							  Series[ i + 6 ] *
							  Series[ i + 7 ] *
							  Series[ i + 8 ] *
							  Series[ i + 9 ] *
							  Series[ i + 10 ] *
							  Series[ i + 11 ] *
							  Series[ i + 12 ];

				Products.Add(Product);
				if ( Product >= Products.Max() )
				{
					AdjacentNums.Clear();
					for ( int j = 0; j < 13; j++ )
					{
						AdjacentNums.Add(Series[ i + j ]);
					}
				}
			}

			Console.Write("Adjacent numbers are : ");
			foreach ( Int64 k in AdjacentNums )
			{
				Console.Write(k + ", ");
			}
			Console.WriteLine();
			Console.Write("product is : " + Products.Max());
		}

		/// <summary>
		/// PROBLEM 9.
		/// 
		/// </summary>
		public static int p009_SpecialPythagoreanTriplet()
		{
			int Result = 0;
			bool exit = false;
			List<int> Squares = new List<int>();

			//loop to add items to squares list
			for ( int i = 1; i <= 450; i++ )
			{
				Squares.Add(i);
			}
			for ( int i = 0; i < Squares.Count; i++ )
			{
				if ( exit == false )
				{
					for ( int j = 1; j < Squares.Count; j++ )
					{
						//int SumOfTwo = Squares[ i ] + Squares[ j ];
						for ( int k = 0; k < Squares.Count; k++ )
						{
							//a^ + b^ = c^; {Pythagorean theory}
							if ( ( Squares[ i ] * Squares[ i ] ) + ( Squares[ j ] * Squares[ j ] ) == ( Squares[ k ] * Squares[ k ] ) )
							{
								//check if sum == 1000
								if ( Squares[ i ] + Squares[ j ] + Squares[ k ] == 1000 )
								{
									Result = Squares[ i ] * Squares[ j ] * Squares[ k ];
									Console.WriteLine($"first number: {Squares[ i ]} \nsecond number: {Squares[ j ]} \nthird number: {Squares[ k ]}\n");
									Console.WriteLine(Result);
									exit = true;
									break;
								}
							}
						}
					}
				}
			}
			return Result;
		}

		/// <summary>
		/// PROBLEM 10.
		/// Sum of all primes below two million.
		/// </summary>
		public static void p010_SummationOfPrimes()
		{
			Int64 c = 5;

			for ( int i = 2; i < 2000000; i++ )
			{
				for ( int j = 2; j <= i / 2; j++ )
				{
					if ( i % j == 0 )
					{
						break;
					}
					else if ( j == i / 2 )
					{
						c += i;
						Console.WriteLine(i);
						break;
					}
				}
			}
			Console.WriteLine(c);
		}

		/// <summary>
		/// PROBLEM 12.
		/// The first triangle number with five hundred factors.
		/// </summary>
		static public void p012_TriangleNumWithOver500Factors()
		{
			int c = 0;
			for ( int i = 1; ; i++ )
			{
				int d = 2;
				c += i;
				for ( int j = 2; j <= c / 2; j++ )
				{
					if ( c % j == 0 )
					{
						d++;
					}
				}
				if ( d >= 500 )
				{
					Console.WriteLine($"{c} has {d} factors.");
					break;
				}
			}
		}

		/// <summary>
		/// PROBLEM 13. 
		/// The first ten digits of the sum of a hundred 50 digit numbers (from a txt file).
		/// </summary>
		static public void p013_SumOfNumsinReverse()
		{
			//eular problem 13
			string a = "";
			int c = 0;
			for ( int p = 49; p >= 0; p-- )
			{
				using ( StreamReader sw = new StreamReader("./Problem13.txt") )
				{
					int r = c;

					for ( int i = 0; i < 100; i++ )
					{
						string s = sw.ReadLine();
						int j = int.Parse(s[ p ].ToString());
						r += j;
					}
					a += r.ToString()[ r.ToString().Length - 1 ];
					c = Convert.ToInt32(r.ToString().Substring(0, r.ToString().Length - 1));
				}
			}
			a += c.ToString();
			Console.WriteLine(new String(a.ToArray().Reverse().ToArray()).Substring(0, 10));
		}

		/// <summary>
		/// PROBLEM 14.
		/// Collatz sequence with most nums in sequence.
		/// </summary>
		public static void p014_FindCollatzSequence()
		{
			//eular problem 14
			//Collatz Sequence
			//n → n / 2(n is even)
			//n → 3n + 1(n is odd)

			int max = 0;
			int res = 0;
			for ( int i = 13; i < 1000000; i++ )
			{
				int c = 1;
				Int64 n = i;
				while ( n > 1 )
				{
					n = n % 2 == 0 ? n / 2 : n * 3 + 1;
					c++;
				}
				res = c > max ? i : res;
				max = c > max ? c : max;
			}
			Console.WriteLine($"{res} has {max} nums in sequence.");
		}

		/// <summary>
		/// PROBLEM 15.
		/// By moving only right & down in a 20x20 grid. how many possible moves are there?
		/// </summary>
		/// <param name="grid">Number of columns and rows.</param>
		public static async void p015_MovesInGrid( int grid )
		{
			//use the combination formula [n! / r! (n - r)!]
			/*
                 n!                       40!                              40!
            ___________    ====>   ________________      ====>         ___________

            r! (n - r)!              20! (40 - 20)!                     20! x 20!

            */

			string n = "1";
			Task t = new Task(() =>
			{
				for ( int i = grid * 2; i > 1; i-- )
				{
					n = MultiplyLongNums(i.ToString(), n);
				}
			});
			t.Start();
			await t;

			string r = "1";
			string rbyr = "";

			Task t2 = new Task(() =>
			{
				for ( int i = grid; i > 1; i-- )
				{
					r = MultiplyLongNums(i.ToString(), r);
				}
				rbyr = MultiplyLongNums(r, r);
			});
			t2.Start();
			await t2;

			if ( t.IsCompleted && t2.IsCompleted )
			{

				n = n.Insert(n.Length - ( rbyr.Length - 1 ), ".");
				rbyr = rbyr.Insert(1, ".");

				double d = double.Parse(n) / double.Parse(rbyr);

				//Console.WriteLine(n);
				//Console.WriteLine(rbyr );
				Console.ForegroundColor = ConsoleColor.Green;
				Console.WriteLine(d);
			}
		}

		public static UInt64 p015( UInt64 m, UInt64 n, Dictionary<string, UInt64> memo )
		{
			string key = $"{m},{n}";
			if ( memo.ContainsKey(key) )
			{
				return memo[ key ];
			}
			if ( m == 0 || n == 0 )
			{
				return 0;
			}
			if ( m == 1 && n == 1 )
			{
				return 1;
			}
			memo.Add(key, p015(m - 1, n, memo) + p015(m, n - 1, memo));
			return memo[ key ];
		}

		/// <summary>
		/// PROBLEM 16.
		/// Sum of digits produced by 2 to the power 100.
		/// </summary>
		public static void p016_FindPowerDigitSum()
		{
			string R = "2";
			for ( int i = 1; i < 1000; i++ )
			{
				R = MultiplyLongNums(R, "2");
			}
			Console.WriteLine(R);
			Console.WriteLine("--------------------------------------");
			Console.Write("Sum : ");
			Console.WriteLine(Array.ConvertAll(R.ToArray(), a => int.Parse(a.ToString())).Sum());
		}

		/// <summary>
		/// Multiply big numbers of any size [DEPRECATED]. (Use System.BigInteger)
		/// </summary>
		/// <param name="a">First number.</param>
		/// <param name="b">Second number.</param>
		/// <returns>Product of first and second number.</returns>
		private static string MultiplyLongNums( string a, string b )
		{
			string num1 = a.Length == b.Length ? a : a.Length > b.Length ? a : b;
			string num2 = b.Length == a.Length ? b : b.Length < a.Length ? b : a;
			string main_res = "0";

			for ( int i = 0; i < num2.Length; i++ )
			{
				int multiplier = int.Parse(num2[ i ].ToString());
				int carry = 0;
				string _res = "";

				for ( int k = 0; k < num2.Length - ( i + 1 ); k++ )
				{
					_res += "0";
				}

				for ( int j = num1.Length - 1; j >= 0; j-- )
				{
					string temp_res = ( int.Parse(num1[ j ].ToString()) * multiplier + carry ).ToString();
					carry = j == 0 ? 0 : temp_res.Length > 1 ? int.Parse(temp_res.Substring(0, temp_res.Length - 1)) : 0;
					_res = j == 0 ? temp_res + _res : temp_res.Length > 1 ? temp_res[ temp_res.Length - 1 ].ToString() + _res : temp_res + _res;

				}
				main_res = AddLongNums(main_res, _res);
			}
			return main_res;
		}

		/// <summary>
		/// Add big numbers of any size [DEPRECATED]. (Use System.BigInteger)
		/// </summary>
		/// <param name="num1">First number.</param>
		/// <param name="num2">Second number.</param>
		/// <returns>Sum of first and second number.</returns>
		private static string AddLongNums( string num1, string num2 )
		{
			//make sure bigger num is at the top
			string bger_num = num1.Length == num2.Length ? num1 : num1.Length > num2.Length ? num1 : num2;
			string smlr_num = num2.Length == num1.Length ? num2 : num2.Length < num1.Length ? num2 : num1;
			string _res = "";
			string sum = "";
			int carry = 0;
			for ( int j = 1; j <= bger_num.Length; j++ )
			{
				try
				{
					sum = ( int.Parse(bger_num[ bger_num.Length - j ].ToString()) + int.Parse(smlr_num[ smlr_num.Length - j ].ToString()) + carry ).ToString();
				}
				catch
				{
					sum = ( int.Parse(bger_num[ bger_num.Length - j ].ToString()) + carry ).ToString();
				}
				carry = j == 0 ? 0 : sum.Length > 1 ? int.Parse(sum.Substring(0, sum.Length - 1)) : 0;
				_res = j == bger_num.Length ? sum + _res : sum[ sum.Length - 1 ].ToString() + _res;
			}
			return _res;
		}

		/// <summary>
		/// PROBLEM 17.
		/// Write a number in words and counting number of letters.
		/// </summary>
		public static void p017_LetterCount()
		{
			int output = 0;

			string result = null;

			string[] ones = { "one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten" };
			string[] tens = { "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen" };
			string[] hundreds = { "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety" };

			for ( int number = 1; number <= 1000; number++ )
			{
				if ( number <= 10 )
				{
					result = ones[ number - 1 ];
				}
				else if ( number <= 19 )
				{
					result = tens[ number - 11 ];
				}
				else if ( number <= 99 )
				{
					string num = number.ToString();
					result = num[ 1 ] == '0' ? $"{hundreds[ int.Parse(num[ 0 ].ToString()) - 2 ] }" : $"{hundreds[ int.Parse(num[ 0 ].ToString()) - 2 ] } {ones[ int.Parse(num[ 1 ].ToString()) - 1 ]}";
				}
				else if ( number <= 999 )
				{
					string num = number.ToString();
					string first_part = ones[ int.Parse(num[ 0 ].ToString()) - 1 ] + " hundred";
					string second_part = "";

					if ( num.Substring(1, 2) != "00" )
					{

						if ( num[ 1 ] == '0' )
						{
							second_part = "and " + $"{ones[ int.Parse(num[ 2 ].ToString()) - 1 ]}";

						}
						else if ( num[ 2 ] == '0' )
						{
							second_part = num[ 1 ] == '1' ? $"and {ones[ 9 ]}" : "and " + $"{hundreds[ int.Parse(num[ 1 ].ToString()) - 2 ] }";
						}

						else
						{
							int n = int.Parse(num.Substring(1, 2));
							if ( n <= 19 )
							{
								second_part = $"and {tens[ n - 11 ]}";
							}
							else if ( n <= 99 )
							{
								second_part = $"and {hundreds[ int.Parse(num[ 1 ].ToString()) - 2 ] } {ones[ int.Parse(num[ 2 ].ToString()) - 1 ]}";
							}
						}
					}

					result = $"{first_part} {second_part}";

				}
				else if ( number == 1000 )
				{
					result = "one thousand";
				}

				Console.WriteLine(number + ". " + result);
				output += result.Replace(" ", "").Length;
			}
			Console.ForegroundColor = ConsoleColor.Green;
			Console.WriteLine("\n" + output + " words.");
		}

		/// <summary>
		/// PROBLEM 18.
		/// Find a path in a tree of numbers, with highest sum (from txt file).
		/// </summary>
		public static void p018_MaxPathSum_1()
		{
			//brute force <by comparing all the possible paths> 2 ^ rows - 1 
			List<int[]> lstNums = new List<int[]>();
			//store all nums in an array
			using ( StreamReader sr = new StreamReader("./Problem18.txt") )
			{
				string num = "";
				while ( ( num = sr.ReadLine() ) != null )
				{
					lstNums.Add(Array.ConvertAll(num.Trim().Split(' '), a => int.Parse(a)));
				}
			}


			/*in a tree with 2 children each child is either 0 or 1
            which can be seen as a binary number.
            if a tree has a depth of 15 then ==> 0-0-0-0-0-0-0-0-0-0-0-0-0-0-0 first route ==> 0
                                                 0-0-0-0-0-0-0-0-0-0-0-0-0-0-1 sec route    ==> 1
                                                 0-0-0-0-0-0-0-0-0-0-0-0-0-1-0 third route  ==> 2

            hence just iterate all natural nums from 0 to 2^depth-1 [and covert them to a 15 digit binary num] ==> the binary equiv is the route 
            */
			int max = ( int ) Math.Pow(2, lstNums.Count - 1);
			int best_res = 0;
			string best_route = "";
			for ( int i = 0; i < max; i++ )
			{
				//prepend needed zeros so bin has 15 digits
				string pholder = "";
				for ( int l = 0; l < lstNums.Count; l++ )
				{
					pholder += "0";
				}
				//convert i to binary
				string bin = Convert.ToString(i, 2);
				bin = pholder.Substring(0, pholder.Length - bin.Length) + bin;
				int[] route_array = Array.ConvertAll(bin.ToArray(), a => int.Parse(a.ToString()));
				int res = 0;
				string route = "";

				for ( int j = 0; j < lstNums.Count; j++ )
				{
					int total = 0;
					for ( int k = 0; k < j; k++ )
					{
						total += route_array[ k ];
					}
					int n = lstNums[ j ][ route_array[ j ] + total ];
					res += n;
					route += n.ToString() + " ";
				}
				best_route = res > best_res ? route : best_route;
				best_res = res > best_res ? res : best_res;
			}

			//print out the pyramid
			best_route = best_route.Trim();
			int[] correct_route_nums = Array.ConvertAll(best_route.Split(' ').ToArray(), a => int.Parse(a.ToString()));

			for ( int i = 0; i < lstNums.Count; i++ )
			{
				int[] nums = lstNums[ i ];
				for ( int j = 0; j < lstNums.Count - nums.Length; j++ )
				{
					Console.Write("  ");
				}
				for ( int k = 0; k < nums.Length; k++ )
				{
					int n = nums[ k ];
					if ( n == correct_route_nums[ i ] )
					{
						Console.ForegroundColor = ConsoleColor.Red;
					}
					string ns = n < 10 ? "0" + n : n.ToString();
					Console.Write(ns + "  ");
					Console.ForegroundColor = ConsoleColor.White;
				}
				Console.WriteLine();
			}

			Console.ForegroundColor = ConsoleColor.Green;
			Console.Write("sum: " + best_res);
			Console.ReadLine();

		}

		/// <summary>
		/// PROBLEM 19.
		/// First days of a month that are on a sunday.
		/// </summary>
		public static void p019_CountingSundays()
		{
			DateTime date = new DateTime(1901, 1, 1);
			DateTime d = new DateTime(2000, 12, 31);
			int c = 0;
			while ( date <= d )
			{
				if ( date.Day == 1 && date.DayOfWeek == DayOfWeek.Sunday )
				{
					c++;
				}
				date = date.AddMonths(1);
			}
			Console.WriteLine(c + " sundays.");
		}

		/// <summary>
		/// PROBLEM 20.
		/// The sum of the digits in the number 100! (factorial of one hundred).
		/// </summary>
		public static void p020_FactorialDigitSum()
		{
			/*using recursive function is slower*/
			/*use loop*/
			string res = "100";
			for ( int i = int.Parse(res); i > 2; i-- )
			{
				//this is a custome method for mul long nums
				res = MultiplyLongNums(res, ( i - 1 ).ToString());
			}

			Console.WriteLine("100! = " + res);
			Console.WriteLine("sum: " + Array.ConvertAll(res.ToArray(), a => int.Parse(a.ToString())).Sum());
		}

		/// <summary>
		/// PROBLEM 21.
		/// Let d(n) be defined as the sum of proper divisors of n (numbers less than n which divide evenly into n).
		/// If d( a) = b and d( b) = a, where a ≠ b, then a and b are an amicable pair and each of a and b are called amicable numbers.
		/// For example, the proper divisors of 220 are 1, 2, 4, 5, 10, 11, 20, 22, 44, 55 and 110; therefore d(220) = 284. 
		/// The proper divisors of 284 are 1, 2, 4, 71 and 142; so d(284) = 220.
		/// Find the sum of all the amicable numbers below 10000.
		/// </summary>
		public static void p021_AmicableNumbers()
		{
			int res = 0;

			for ( int i = 1; i <= 10000; i++ )
			{
				//find divisors of i and add them together
				int sum = 0;
				for ( int j = 1; j <= i / 2; j++ )
				{
					if ( i % j == 0 )
					{
						sum += j;
					}
				}
				//find divisors of [sum of divisors of i] and add them together
				int new_sum = 0;
				for ( int k = 1; k <= sum / 2; k++ )
				{
					if ( sum % k == 0 )
					{
						new_sum += k;
					}
				}
				//determine if d(i) == sum && d(sum) == i && i != sum
				if ( i == new_sum && i != sum )
				{
					res += sum + new_sum;
					i = sum + 1;
				}
			}
			Console.WriteLine($"{res}.");
		}

		/// <summary>
		/// PROBLEM 22.
		/// Example, when the list is sorted into alphabetical order, COLIN, 
		/// - which is worth 3 + 15 + 12 + 9 + 14 = 53, is the 938th name in the list.
		/// - so, COLIN would obtain a score of 938 × 53 = 49714.
		/// Find the total of all the name scores in a file (.txt file).
		/// </summary>
		public static void p022_NameScores()
		{
			List<string> names = new List<string>();
			using ( StreamReader sr = new StreamReader("./Problem22.txt") )
			{
				string[] str = sr.ReadToEnd().Split(',');
				foreach ( string name in str )
				{
					names.Add(name.Replace("\"", ""));
				}
			}
			names.Sort();
			long c = 0;
			for ( int i = 0; i < names.Count; i++ )
			{
				string name = names[ i ];
				int sum = 0;
				foreach ( char cha in name )
				{
					sum += ( int ) cha - 64;
				}
				c += sum * ( i + 1 );

			}
			Console.WriteLine(c);
		}

		/// <summary>
		/// PROBLEM 23.
		/// A number (n) is called abundant if the sum of it's divisors exceeds the number (n).
		/// As 12 is the smallest abundant number, 1 + 2 + 3 + 4 + 6 = 16, the smallest number that can be written as the sum of two abundant numbers is 24.
		/// By mathematical analysis, it can be shown that all integers greater than 28123 can be written as the sum of two abundant numbers.
		/// However, this upper limit cannot be reduced any further by analysis even though it is known that the greatest number that cannot be expressed as the sum of two abundant numbers is less than this limit.
		/// Find the sum of all the positive integers which cannot be written as the sum of two abundant numbers.
		/// </summary>
		public static void p023_NonAbundantNumbers()
		{
			List<int> AbundantNumbers = new List<int>();
			//get all abundant num below limit 28123
			for ( int i = 2; i <= 28123; i++ )
			{
				int j_limit = i / 2;
				int divisors_sum = 0;
				for ( int j = 1; j <= j_limit; j++ )
				{
					divisors_sum = i % j == 0 ? divisors_sum + j : divisors_sum;
				}
				if ( divisors_sum > i )
				{
					AbundantNumbers.Add(i);
				}
			}

			HashSet<int> NumsMadeBy_Abundant = new HashSet<int>();
			//get all nums made my 2 abundant nums
			for ( int a = 0; a < AbundantNumbers.Count; a++ )
			{
				for ( int b = a; b < AbundantNumbers.Count; b++ )
				{
					NumsMadeBy_Abundant.Add(AbundantNumbers[ a ] + AbundantNumbers[ b ]);
				}
			}

			//count non-abundant nums
			int count = 0;
			for ( int c = 1; c <= 28123; c++ )
			{
				count = NumsMadeBy_Abundant.Contains(c) ? count : count + c;
			}
			Console.WriteLine(count);
		}

		/// <summary>
		/// Calculates the factorial of a number less than Int64.MaxValue. 
		/// </summary>
		/// <param name="i">Number</param>
		/// <returns>Factorial of a number.</returns>
		private static long Factorial( long i )
		{
			if ( i <= 1 )
			{
				return 1;
			}
			return i * Factorial(i - 1);
		}

		/// <summary>
		/// PROBLEM 24.
		/// The lexicographic permutations of 1,2,3 are 123 132 213 231 312 321.
		/// Find the millionth lexicographic permutation of the digits 0, 1, 2, 3, 4, 5, 6, 7, 8 and 9.
		/// </summary>
		public static void p024_LexicographicPermutations()
		{
			int[] P = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };
			int times = ( int ) Factorial(( long ) P.Length);

			for ( int j = 0; j < times; j++ )
			{
				//STEP 1: Find the largest x such that P[x]<P[x+1].
				//( If there is no such x, P is the last permutation.)
				int x = -1;
				for ( int i = 0; i < P.Length - 1; i++ )
				{
					x = P[ i ] < P[ i + 1 ] ? i : x;
				}
				if ( x == -1 )
				{
					break;
				}

				//STEP 2 Find the largest y such that P[x]<P[y]
				int y = 0;
				for ( int i = 0; i < P.Length; i++ )
				{
					if ( P[ x ] < P[ i ] )
					{
						y = i;
					}
				}

				//STEP 3 Swap P[x] and P[y].
				int index_x = P[ x ];
				int index_y = P[ y ];
				P[ x ] = index_y;
				P[ y ] = index_x;

				//STEP 4 Reverse P[x+1 .. n].
				int[] new_P = new int[ P.Length ];
				for ( int i = 0; i <= x; i++ )
				{
					new_P[ i ] = P[ i ];
				}
				int c = 1;
				for ( int i = P.Length - 1; i > x; i-- )
				{
					new_P[ x + c ] = P[ i ];
					c++;
				}

				P = new_P;
				if ( j + 2 == 1000000 )
				{
					Console.Write("index: " + ( j + 2 ) + " is ");
					foreach ( int n in new_P )
					{
						Console.Write(n);
					}
					break;
				}
			}
		}

		/// <summary>
		/// PROBLEM 25. 
		/// Find the index of the first term in the Fibonacci sequence to contain 1000 digits?
		/// </summary>
		public static void p025_ThousanDigitFibonacciNumber()
		{
			string n = "";
			string x = "1";
			string y = "2";
			string f = null;
			for ( int i = 3; n.Length < 1000; i++ )
			{
				n = AddLongNums(x, y);
				x = y;
				y = n;
				f = "F" + ( i + 1 );
			}
			Console.WriteLine(f + " is: " + n);
		}

		/// <summary>
		/// PROBLEM 26.
		/// A unit fraction contains 1 in the numerator. The decimal representation of the unit fractions with denominators 2 to 10 are given:
		/// 1/2	= 	0.5
		/// 1/3	= 	0.(3)
		/// 1/4	= 	0.25
		/// 1/5	= 	0.2
		/// 1/6	= 	0.1(6)
		/// 1/7	= 	0.(142857)
		/// 1/8	= 	0.125
		/// 1/9	= 	0.(1)
		/// 1/10	= 	0.1
		/// Where 0.1(6) means 0.166666..., and has a 1-digit recurring cycle.It can be seen that 1/7 has a 6-digit recurring cycle.
		/// Find the value of d< 1000 for which 1/d contains the longest recurring cycle in its decimal fraction part.
		/// </summary>
		public static void p026_ReciprocalCyles()
		{
			string re = "";
			int res = 0;
			for ( int i = 2; i < 1000; i++ )
			{
				int Numerator = 1;
				string result = "";
				int Denominator = i;
				int div_res = 0;
				int[] count = new int[ 10 ];
				while ( result.Length <= 1000 )
				{

					div_res = Numerator / Denominator;

					result += div_res;
					count[ div_res ]++;

					if ( Numerator % Denominator == 0 )
					{

						break;
					}

					Numerator = ( Numerator % Denominator ) * 10;
				}
				result = result.Substring(1);
				//Console.WriteLine($"1/{Denominator} = {result}");
				count[ 0 ]--;//exclude first zero (its the 0 before the comma)
							 //foreach ( int n in count )
							 //{
							 //	Console.Write(n +", ");
							 //}
				count = count.Where(x => x != 0).ToArray();
				int average = ( int ) count.Average();
				int c = count.Where(x => x >= average).Count();
				//Console.WriteLine("\n"+c);
				string l = result.Substring(0, c);
				int y = result.IndexOf(l, 1);
				//Console.WriteLine($"index of {l} = {y}");

				re = res < y ? Denominator.ToString() : re;
				res = res < y ? y : res;
			}
			Console.WriteLine($"1/{re} == {res}-digit recurring cycle ");
			//return result;
		}

		/// <summary>
		/// PROBLEM 27.
		/// Find the product of the coefficients, a and b, for the quadratic expression that produces the maximum number of primes for consecutive values of n, starting with n=0.>
		/// Eulers formula n^2 + an + b == n^2 + n + 41  (a is 1, b is 41).
		/// The incredible formula n^2 − an + b == n^2 − 79n + 1601 (a is -79, b is 1601).
		/// </summary>
		public static void p027_QuadraticPrimes()
		{
			int coe_a = 0;
			int coe_b = 0;
			int val_n = 0;
			int best_primes = 0;

			for ( int a = -999; a < 1000; a++ )
			{
				for ( int b = -1000; b <= 1000; b++ )
				{
					int primes = 0;
					for ( int n = 0; ; n++ )
					{
						int res = Math.Abs(( n * n ) + ( a * n ) + b);
						if ( !CheckPrime(res) )
						{
							bool is_big = primes > best_primes;
							coe_a = is_big ? a : coe_a;
							coe_b = is_big ? b : coe_b;
							val_n = is_big ? n : val_n;
							best_primes = is_big ? primes : best_primes;
							break;
						}
						primes++;
					}
				}
			}
			Console.WriteLine($"{val_n}^2 + ({coe_a} * {val_n}) + {coe_b} = {best_primes} primes ==> {coe_a * coe_b}");
		}

		/// <summary>
		/// [DEPRECATED. Use CheckPrime()]
		/// Check if anumber is aprime or not
		/// </summary>
		/// <param name="number">The number to check</param>
		/// <returns>True if prime or False if even</returns>
		private static bool is_prime( int number )
		{

			int count = 0;
			for ( int i = 1; i <= number / 2; i++ )
			{
				if ( number % i == 0 )
				{
					count++;
				}
			}
			return count >= 2 ? false : true;
		}

		/// <summary>
		/// PROBLEM 28.
		/// Starting with the number 1 and moving to the right in a clockwise direction a 5 by 5 spiral is formed as follows:
		/// 21 22 23 24 25
		/// 20  7  8  9 10
		/// 19  6  1  2 11
		/// 18  5  4  3 12
		/// 17 16 15 14 13
		/// It can be verified that the sum of the numbers on the diagonals is 101.
		/// What is the sum of the numbers on the diagonals in a 1001 by 1001 spiral formed in the same way?
		/// </summary>
		public static void p028_NumberSpiralDiagonals()
		{
			int end = 1001 * 1001;
			int checker = 0;
			int counter = 2;
			int sum = 0;
			for ( int i = 3; i <= end; i += counter )
			{
				sum += i;
				checker += 1;
				counter = checker == 4 ? counter + 2 : counter;
				checker = checker == 4 ? 0 : checker;
			}
			Console.WriteLine(sum + 1);
		}

		/// <summary>
		/// PROBLEM 29.
		/// Consider all integer combinations of ab for 2 ≤ a ≤ 5 and 2 ≤ b ≤ 5:
		/// 22=4, 23=8, 24=16, 25=32
		/// 32=9, 33=27, 34=81, 35=243
		/// 42=16, 43=64, 44=256, 45=1024
		/// 52=25, 53=125, 54=625, 55=3125
		/// If they are then placed in numerical order, with any repeats removed, we get the following sequence of 15 distinct terms:
		/// 4, 8, 9, 16, 25, 27, 32, 64, 81, 125, 243, 256, 625, 1024, 3125
		/// How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 10/// 
		/// </summary>
		public static void p029_DistinctPowers()
		{
			HashSet<double> res = new HashSet<double>();
			int start = 2;
			int end = 100;
			for ( int a = start; a <= end; a++ )
			{
				for ( int b = start; b <= end; b++ )
				{
					res.Add(Math.Pow(a, b));
				}
			}
			Console.WriteLine(res.Count);
		}

		/// <summary>
		/// PROBLEM 30.
		/// Surprisingly there are only three numbers that can be written as the sum of fourth powers of their digits:
		/// 1634 = 1^4 + 6^4 + 3^4 + 4^4,  
		/// 8208 = 8^4 + 2^4 + 0^4 + 8^4, 
		/// 9474 = 9^4 + 4^4 + 7^4 + 4^4,
		/// As 1 = 1^4 is not a sum it is not included.
		/// The sum of these numbers is 1634 + 8208 + 9474 = 19316.
		/// Find the sum of all the numbers that can be written as the sum of fifth powers of their digits.
		/// </summary>
		public static void p030_DigitFifthPowers()
		{
			string n = "";
			int res = 0;
			double sum = 0;
			for ( int i = 2; i <= 1000000; i++ )
			{
				n = i.ToString();
				sum = 0;
				for ( int j = 0; j < n.Length; j++ )
				{
					sum += Math.Pow(int.Parse(n[ j ].ToString()), 5);
				}
				res = ( int ) sum == i ? res + i : res;
			}
			Console.WriteLine(res);
		}

		/// <summary>
		/// PROBLEM 31
		/// In the United Kingdom the currency is made up of pound (£) and pence (p). There are eight coins in general circulation:
		/// 1p, 2p, 5p, 10p, 20p, 50p, £1 (100p), and £2 (200p).
		/// It is possible to make £2 in the following way:
		/// 1×£1 + 1×50p + 2×20p + 1×5p + 1×2p + 3×1p.
		/// How many different ways can £2 be made using any number of coins?
		/// </summary>
		public static void p031_CoinSums()
		{
			List<int> coins = new List<int> { 100, 50, 20, 10, 5, 2, 1 };
			List<int> total = new List<int>();

			for ( int j = 1; j <= 7; j++ )
			{
				int res = PairNumber(j, coins);
				Console.WriteLine(res);
				total.Add(res);
			}
			Console.ForegroundColor = ConsoleColor.Green;
			Console.WriteLine($"Total ways ==> {total.Sum()}");

		}

		/// <summary>
		/// Used by CoinSums() to pair given coins in given number.
		/// </summary>
		/// <param name="pair_in">Number to pair the coins in.</param>
		/// <param name="coins">The coins to pair</param>
		/// <returns>Total pairs that can be made.</returns>
		private static int PairNumber( int pair_in, List<int> coins )
		{
			int res = 0;

			//for pairing each coin by itself
			if ( pair_in == 1 )
			{
				return coins.Count + 1;
			}
			//for pairing every coin by 1 other coin
			else if ( pair_in == 2 )
			{
				for ( int a = 0; a < coins.Count - 1; a++ )
				{
					for ( int b = a + 1; b < coins.Count; b++ )
					{
						int iend = 200 / coins[ a ];
						for ( int i = 1; i <= iend; i++ )
						{
							int jend = ( 200 - ( coins[ a ] * i ) ) / coins[ b ];
							for ( int j = 1; j <= jend; j++ )
							{
								int sum = ( coins[ a ] * i ) + ( coins[ b ] * j );
								if ( sum == 200 )
								{
									res++;
									//Console.WriteLine($"{i}x{coins[ a ]}p + {j}x{coins[ b ]}p");
								}
							}
						}
					}
				}

				return res;
			}

			else if ( pair_in == 3 )
			{
				for ( int a = 0; a < coins.Count - 2; a++ )
				{
					for ( int b = a + 1; b < coins.Count - 1; b++ )
					{
						for ( int c = b + 1; c < coins.Count; c++ )
						{
							int iend = 200 / coins[ a ];
							for ( int i = 1; i <= iend; i++ )
							{
								int jend = ( 200 - ( coins[ a ] * i ) ) / coins[ b ];
								for ( int j = 1; j <= jend; j++ )
								{
									int kend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) ) / coins[ c ];
									for ( int k = 1; k <= kend; k++ )
									{
										int sum = ( coins[ a ] * i ) + ( coins[ b ] * j ) + ( coins[ c ] * k );
										if ( sum == 200 )
										{
											res++;
											//Console.WriteLine($"{i}x{coins[a]}p + {j}x{coins[ b ]}p + {k}x{coins[ c ]}p");
										}
									}
								}
							}
						}
					}
				}
				return res;
			}

			else if ( pair_in == 4 )
			{
				for ( int a = 0; a < coins.Count - 3; a++ )
				{
					for ( int b = a + 1; b < coins.Count - 2; b++ )
					{
						for ( int c = b + 1; c < coins.Count - 1; c++ )
						{
							for ( int d = c + 1; d < coins.Count; d++ )
							{
								int iend = 200 / coins[ a ];
								for ( int i = 1; i <= iend; i++ )
								{
									int jend = ( 200 - ( coins[ a ] * i ) ) / coins[ b ];
									for ( int j = 1; j <= jend; j++ )
									{
										int kend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) ) / coins[ c ];
										for ( int k = 1; k <= kend; k++ )
										{
											int lend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) - ( coins[ c ] * k ) ) / coins[ d ];
											for ( int l = 1; l <= lend; l++ )
											{
												int sum = ( coins[ a ] * i ) + ( coins[ b ] * j ) + ( coins[ c ] * k ) + ( coins[ d ] * l );
												if ( sum == 200 )
												{
													res++;
													//Console.WriteLine($"{i}x{coins[ a ]}p + {j}x{coins[ b ]}p + {k}x{coins[ c ]}p + {l}x{coins[ d ]}p");
												}
											}
										}
									}
								}
							}
						}
					}
				}
				return res;
			}

			else if ( pair_in == 5 )
			{
				for ( int a = 0; a < coins.Count - 4; a++ )
				{
					for ( int b = a + 1; b < coins.Count - 3; b++ )
					{
						for ( int c = b + 1; c < coins.Count - 2; c++ )
						{
							for ( int d = c + 1; d < coins.Count - 1; d++ )
							{
								for ( int e = d + 1; e < coins.Count; e++ )
								{
									int iend = 200 / coins[ a ];
									for ( int i = 1; i <= iend; i++ )
									{
										int jend = ( 200 - ( coins[ a ] * i ) ) / coins[ b ];
										for ( int j = 1; j <= jend; j++ )
										{
											int kend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) ) / coins[ c ];
											for ( int k = 1; k <= kend; k++ )
											{
												int lend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) - ( coins[ c ] * k ) ) / coins[ d ];
												for ( int l = 1; l <= lend; l++ )
												{
													int mend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) - ( coins[ c ] * k ) - ( coins[ d ] * l ) ) / coins[ e ];
													for ( int m = 1; m <= mend; m++ )
													{

														int sum = ( coins[ a ] * i ) + ( coins[ b ] * j ) + ( coins[ c ] * k ) + ( coins[ d ] * l ) + ( coins[ e ] * m );
														if ( sum == 200 )
														{
															res++;
															//Console.WriteLine($"{i}x{coins[ a ]}p + {j}x{coins[ b ]}p + {k}x{coins[ c ]}p + {l}x{coins[ d ]}p + {m}x{coins[ e ]}p");
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				return res;
			}

			else if ( pair_in == 6 )
			{
				for ( int a = 0; a < coins.Count - 5; a++ )
				{
					for ( int b = a + 1; b < coins.Count - 4; b++ )
					{
						for ( int c = b + 1; c < coins.Count - 3; c++ )
						{
							for ( int d = c + 1; d < coins.Count - 2; d++ )
							{
								for ( int e = d + 1; e < coins.Count - 1; e++ )
								{
									for ( int f = e + 1; f < coins.Count; f++ )
									{

										int iend = 200 / coins[ a ];
										for ( int i = 1; i <= iend; i++ )
										{
											int jend = ( 200 - ( coins[ a ] * i ) ) / coins[ b ];
											for ( int j = 1; j <= jend; j++ )
											{
												int kend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) ) / coins[ c ];
												for ( int k = 1; k <= kend; k++ )
												{
													int lend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) - ( coins[ c ] * k ) ) / coins[ d ];
													for ( int l = 1; l <= lend; l++ )
													{
														int mend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) - ( coins[ c ] * k ) - ( coins[ d ] * l ) ) / coins[ e ];
														for ( int m = 1; m <= mend; m++ )
														{
															int nend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) - ( coins[ c ] * k ) - ( coins[ d ] * l ) - ( coins[ e ] * m ) ) / coins[ f ];
															for ( int n = 1; n <= nend; n++ )
															{


																int sum = ( coins[ a ] * i ) + ( coins[ b ] * j ) + ( coins[ c ] * k ) + ( coins[ d ] * l ) + ( coins[ e ] * m ) + ( coins[ f ] * n );
																if ( sum == 200 )
																{
																	res++;
																	//Console.WriteLine($"{i}x{coins[ a ]}p + {j}x{coins[ b ]}p + {k}x{coins[ c ]}p + {l}x{coins[ d ]}p + {m}x{coins[ e ]}p + {n}x{coins[ f ]}p");
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				return res;
			}

			else if ( pair_in == 7 )
			{
				for ( int a = 0; a < coins.Count - 6; a++ )
				{
					for ( int b = a + 1; b < coins.Count - 5; b++ )
					{
						for ( int c = b + 1; c < coins.Count - 4; c++ )
						{
							for ( int d = c + 1; d < coins.Count - 3; d++ )
							{
								for ( int e = d + 1; e < coins.Count - 2; e++ )
								{
									for ( int f = e + 1; f < coins.Count - 1; f++ )
									{
										for ( int g = f + 1; g < coins.Count; g++ )
										{



											int iend = 200 / coins[ a ];
											for ( int i = 1; i <= iend; i++ )
											{
												int jend = ( 200 - ( coins[ a ] * i ) ) / coins[ b ];
												for ( int j = 1; j <= jend; j++ )
												{
													int kend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) ) / coins[ c ];
													for ( int k = 1; k <= kend; k++ )
													{
														int lend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) - ( coins[ c ] * k ) ) / coins[ d ];
														for ( int l = 1; l <= lend; l++ )
														{
															int mend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) - ( coins[ c ] * k ) - ( coins[ d ] * l ) ) / coins[ e ];
															for ( int m = 1; m <= mend; m++ )
															{
																int nend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) - ( coins[ c ] * k ) - ( coins[ d ] * l ) - ( coins[ e ] * m ) ) / coins[ f ];
																for ( int n = 1; n <= nend; n++ )
																{

																	int oend = ( 200 - ( coins[ a ] * i ) - ( coins[ b ] * j ) - ( coins[ c ] * k ) - ( coins[ d ] * l ) - ( coins[ e ] * m ) - ( coins[ f ] * n ) ) / coins[ g ];
																	for ( int o = 1; o <= oend; o++ )
																	{
																		int sum = ( coins[ a ] * i ) + ( coins[ b ] * j ) + ( coins[ c ] * k ) + ( coins[ d ] * l ) + ( coins[ e ] * m ) + ( coins[ f ] * n ) + ( coins[ g ] * o );
																		if ( sum == 200 )
																		{
																			res++;
																			//Console.WriteLine($"{i}x{coins[ a ]}p + {j}x{coins[ b ]}p + {k}x{coins[ c ]}p + {l}x{coins[ d ]}p + {m}x{coins[ e ]}p + {n}x{coins[ f ]}p");

																		}


																	}
																}
															}
														}
													}
												}
											}
										}
									}
								}
							}
						}
					}
				}
				return res;
			}

			return 0;
		}

		/// <summary>
		/// PROBLEM 32.
		/// We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once; for example, the 5-digit number, 15234, is 1 through 5 pandigital.
		/// The product 7254 is unusual, as the identity, 39 × 186 = 7254, containing multiplicand, multiplier, and product is 1 through 9 pandigital.
		/// Find the sum of all products whose multiplicand/multiplier/product identity can be written as a 1 through 9 pandigital.
		/// HINT: Some products can be obtained in more than one way so be sure to only include it once in your sum.
		/// </summary>
		public static void p032_PandigitalProducts()
		{
			Stopwatch clock = Stopwatch.StartNew();

			HashSet<int> Identity = new HashSet<int>();
			HashSet<int> sum = new HashSet<int>();

			for ( int i = 1; i <= 99; i++ )
			{
				for ( int j = i + 1; j <= 9999; j++ )
				{
					string i_num = i.ToString();
					string j_num = j.ToString();
					int product = i * j;
					string product_num = product.ToString();
					string s = $"{i_num}{j_num}{product_num}";
					if ( s.Contains("0") || s.Length < 9 )
					{
						goto end;
					}

					//check if multiplicand is pandigital
					foreach ( char num in i_num )
					{
						int x = int.Parse(num.ToString());
						if ( !Identity.Add(x) )
						{
							goto end;
						}
					}
					//check if multiplier is pandigital
					foreach ( char num in j_num )
					{
						int x = int.Parse(num.ToString());
						if ( !Identity.Add(x) )
						{
							goto end;
						}
					}
					//check if product is pandigital
					foreach ( char num in product_num )
					{
						int x = int.Parse(num.ToString());
						if ( !Identity.Add(x) )
						{
							goto end;
						}
					}

					bool isPanDig = Identity.Contains(0) ? false : Identity.Sum() == 45 ? true : false;

					if ( isPanDig && sum.Add(product) )
					{
						Console.WriteLine($"{i} x {j} = {product}");
					}


				end:
					Identity.Clear();
				}
			}
			Console.WriteLine($"sum of all pandigital products : {sum.Sum()}");
			Console.WriteLine("Solution took {0} ms", clock.ElapsedMilliseconds);
		}

		//faster way ( NOT MY SOLUTION) for p032
		public static void BruteForce()
		{
			List<long> products = new List<long>();
			long sum = 0;
			long prod, compiled;

			for ( long m = 2; m < 100; m++ )
			{
				long nbegin = ( m > 9 ) ? 123 : 1234;
				long nend = 10000 / m + 1;

				for ( long n = nbegin; n < nend; n++ )
				{
					prod = m * n;
					compiled = concat(concat(prod, n), m);
					if ( compiled >= 1E8 && compiled < 1E9 && isPandigital(compiled) )
					{
						if ( !products.Contains(prod) )
						{
							Console.WriteLine($"{m} x {n} = {prod}");
							products.Add(prod);
						}
					}
				}
			}

			for ( int i = 0; i < products.Count; i++ )
			{
				sum += products[ i ];
			}

			Console.WriteLine("The sum of all pan digital number from 1-9 is {0}", sum);
		}
		private static long concat( long a, long b )
		{

			long c = b;
			while ( c > 0 )
			{
				a *= 10;
				c /= 10;
			}

			return a + b;
		}
		private static bool isPandigital( long n )
		{
			int digits = 0;
			int count = 0;
			int tmp;

			while ( n > 0 )
			{
				tmp = digits;
				digits = digits | 1 << ( int ) ( ( n % 10 ) - 1 ); //The minus one is there to make 1 fill the first bit and so on
				if ( tmp == digits )
				{ //Check to see if the same digit is found multiple times
					return false;
				}

				count++;
				n /= 10;
			}

			return digits == ( 1 << count ) - 1;
		}

		/// <summary>
		/// PROBLEM 33.
		/// The fraction 49/98 is a curious fraction, as an inexperienced mathematician in attempting to simplify it may incorrectly believe that 49/98 = 4/8, which is correct, is obtained by cancelling the 9s.
		/// We shall consider fractions like, 30/50 = 3/5, to be trivial examples.
		/// There are exactly four non-trivial examples of this type of fraction, less than one in value, and containing two digits in the numerator and denominator.
		/// If the product of these four fractions is given in its lowest common terms, find the value of the denominator.
		/// </summary>
		public static void p033_DigitCancellingFracts()
		{
			double res = 1.0d;
			for ( int n = 10; n < 100; n++ )//numerator
			{
				for ( int d = n + 1; d < 100; d++ )//denominator
				{
					if ( n % 10 == 0 || d % 10 == 0 )//If the numerator or denominator are mod 10, skip it
					{
						continue;
					}
					//if the numerator and denominator share a common digit
					char common = 'a';
					bool shares = false;
					string[] n_d = new string[] { n.ToString(), d.ToString() };
					foreach ( char item in n_d[ 0 ] )
					{
						if ( n_d[ 1 ].Contains(item) )
						{
							shares = true;
							common = item;
							break;
						}
					}
					if ( shares )
					{
						//divide numerator and denominator and store the result in ‘expected’
						double expected = ( double ) n / ( double ) d;
						//remove the common digit from numerator and denominator (generating num’ and denom’)
						n_d[ 0 ] = n_d[ 0 ].Remove(n_d[ 0 ].IndexOf(common), 1);
						n_d[ 1 ] = n_d[ 1 ].Remove(n_d[ 1 ].IndexOf(common), 1);

						//divide num’ and denom’ and compare the result to ‘expected
						double exp = double.Parse(n_d[ 0 ]) / double.Parse(n_d[ 1 ]);
						if ( expected == exp )//if the results match then I have found one of the four answers
						{
							Console.WriteLine($"{n}/{d}");
							res *= exp;
						}
					}
				}
			}
			//report answer
			Console.ForegroundColor = ConsoleColor.Green;
			Console.WriteLine("product of all four curious fracts is: " + res);
			//return res;
		}

		/// <summary>
		/// PROBLEM 34.
		/// 145 is a curious number, as 1! + 4! + 5! = 1 + 24 + 120 = 145.
		/// Find the sum of all numbers which are equal to the sum of the factorial of their digits.
		/// Note: As 1! = 1 and 2! = 2 are not sums they are not included.
		/// </summary>
		public static void p034_DigitFactorials()
		{
			//calculate factorials of 0 - 9
			int[] facts = new int[ 10 ];
			for ( int i = 0; i < 10; i++ )
			{
				facts[ i ] = ( int ) Factorial(( long ) i);
			}
			int res = 0;
			//find curious numbers
			for ( int i = 10; i < 100000; i++ )
			{
				string num = i.ToString();
				int sum = 0;
				//add values
				foreach ( char item in num )
				{
					sum += facts[ int.Parse(item.ToString()) ];
				}
				if ( sum == i )
				{
					res += sum;
					Console.WriteLine(i);
				}
			}
			Console.ForegroundColor = ConsoleColor.Green;
			Console.WriteLine("sum: " + res);
		}

		/// <summary>
		/// PROBLEM 35.
		/// The number, 197, is called a circular prime because all rotations of the digits: 197, 971, and 719, are themselves prime.
		/// There are thirteen such primes below 100: 2, 3, 5, 7, 11, 13, 17, 31, 37, 71, 73, 79, and 97.
		/// How many circular primes are there below one million?
		/// </summary>
		public static void p035_CircularPrimes()
		{
			int max = 1000000;
			int[] primes = new int[ max ];
			int count = 0;
			//find all primes below 1million
			for ( int i = 2; i < max; i++ )
			{
				bool isp = true;
				if ( primes[ i ] != i )
				{
					isp = CheckPrime(i);
				}

				if ( isp )
				{
					//store primes
					primes[ i ] = i;
					List<char> num = i.ToString().ToList();
					for ( int j = 1; j < num.Count; j++ )
					{
						//rotate the number
						num.Add(num[ 0 ]);
						num.RemoveAt(0);

						//check if rotations are circular primes
						int rot = int.Parse(new string(num.ToArray()));

						if ( primes[ rot ] == 0 )//not in array and could be prime
						{
							if ( CheckPrime(rot) )//is prime
							{
								primes[ rot ] = rot;//add to array
							}
							else//not prime 
							{
								break;//exit loop
							}
						}
						count = j == num.Count - 1 ? count + 1 : count;
					}
				}
			}
			Console.WriteLine($"there are {count + 4} circular primes below {max}.");
		}

		/// <summary>
		/// Check if a number is a prime number.
		/// </summary>
		/// <param name="number">NUmber to check</param>
		/// <returns>True if the number is a prime number else False.</returns>
		private static bool CheckPrime( int number )
		{
			if ( number == 2 )
			{
				return true;
			}
			if ( number % 2 == 0 || number == 1 )
			{
				return false;
			}
			double sq = Math.Sqrt(number);
			for ( int i = 3; i <= sq; i += 2 )
			{
				if ( number % i == 0 )
				{
					return false;
				}
			}
			return true;
		}

		/// <summary>
		/// PROBLEM 36.
		/// The decimal number, 585 = 10010010012 (binary), is palindromic in both bases.
		/// Find the sum of all numbers, less than one million, which are palindromic in base 10 and base 2.
		/// (Please note that the palindromic number, in either base, may not include leading zeros.)
		/// </summary>
		private static void p036_DoubleBasePalindromes()
		{
			int sum = 0;
			for ( int i = 0; i < 1000000; i++ )
			{
				string straight = i.ToString();
				string reverse = null;
				for ( int j = straight.Length - 1; j >= 0; j-- )//reverse number
				{
					reverse += straight[ j ];
				}

				if ( i == int.Parse(reverse) )//if palindromic in base 10
				{
					string bin_straight = Convert.ToString(i, 2);
					string bin_reverse = null;
					for ( int k = bin_straight.Length - 1; k >= 0; k-- )//reverse binary number
					{
						bin_reverse += bin_straight[ k ];
					}
					if ( i == Convert.ToInt32(bin_reverse, 2) )//if palindromic in base 2
					{
						Console.WriteLine($"{i} = {bin_straight}");
						sum += i;
					}
				}
			}
			Console.ForegroundColor = ConsoleColor.Green;
			Console.WriteLine($"sum = {sum}");
		}

		/// <summary>
		/// PROBLEM 37.
		/// The number 3797 has an interesting property. Being prime itself, it is possible to continuously remove digits from left to right, and remain prime at each stage: 3797, 797, 97, and 7. Similarly we can work from right to left: 3797, 379, 37, and 3.
		/// Find the sum of the only eleven primes that are both truncatable from left to right and right to left.
		/// NOTE: 2, 3, 5, and 7 are not considered to be truncatable primes.
		/// </summary>
		public static void p037_TrancactiblePrimes()
		{
			int max = 1000000;
			int[] primes = new int[ max ];
			int sum = 0;
			//find all primes below 1million
			for ( int i = 10; i < max; i++ )
			{
				bool isp = true;
				if ( primes[ i ] != i )
				{
					isp = CheckPrime(i);
				}

				if ( isp )
				{
					primes[ i ] = i;

					//remove digits left to right
					string num = i.ToString();
					for ( int j = 0; j < num.Length - 1; j++ )
					{
						string n = null;
						for ( int k = j + 1; k < num.Length; k++ )
						{
							n += num[ k ];
						}
						int new_n = int.Parse(n);
						if ( primes[ new_n ] == 0 )
						{
							if ( CheckPrime(new_n) )
							{
								primes[ new_n ] = new_n;
							}
							else goto end;
						}
					}
					//remove digits right to left
					for ( int j = 0; j < num.Length - 1; j++ )
					{
						string n = num.Remove(num.Length - 1 - j);
						if ( n != null )
						{
							int new_n = int.Parse(n);
							if ( primes[ new_n ] == 0 )//either not prime or not calculated
							{
								if ( CheckPrime(new_n) )//is it prime
								{
									primes[ new_n ] = new_n;
								}
								else goto end;
							}
						}
					}

					Console.WriteLine(i);
					sum += i;
				}
			end:
				continue;
			}
			Console.ForegroundColor = ConsoleColor.Green;
			Console.WriteLine($"sum of all trunctable primes = {sum}");
		}

		/// <summary>
		/// PROBLEM 38.
		/// Take the number 192 and multiply it by each of 1, 2, and 3:
		/// 192 × 1 = 192
		/// 192 × 2 = 384
		/// 192 × 3 = 576
		/// By concatenating each product we get the 1 to 9 pandigital, 192384576. We will call 192384576 the concatenated product of 192 and(1,2,3)
		/// The same can be achieved by starting with 9 and multiplying by 1, 2, 3, 4, and 5, giving the pandigital, 918273645, which is the concatenated product of 9 and(1,2,3,4,5).
		/// What is the largest 1 to 9 pandigital 9-digit number that can be formed as the concatenated product of an integer with(1,2, ... , n) where n > 1?
		/// </summary>
		public static void p038_PandigitalMultiples()
		{
			HashSet<int> pandigits = new HashSet<int>();
			for ( int i = 1; i < 10000; i++ )
			{
				for ( int n = 1; n < 10; n++ )
				{
					string prod = ( i * n ).ToString();
					for ( int item = 0; item < prod.Length; item++ )
					{
						if ( prod[ item ] == '0' ) { goto next; }
						if ( pandigits.Add(int.Parse(prod[ item ].ToString())) )
						{
							if ( pandigits.Count == 9 && item == prod.Length - 1 )
							{
								Console.Write($"{i} when n == {n} : ");
								foreach ( int num in pandigits )
								{
									Console.Write(num);
								}
								Console.WriteLine();
								goto next;
							}
						}
						else
						{
							goto next;
						}
					}
				}
			next:
				pandigits.Clear();
			}
		}

		/// <summary>
		/// PROBLEM 39.
		/// If p is the perimeter of a right angle triangle with integral length sides, {a,b,c}, there are exactly three solutions for p = 120.
		/// {20,48,52}, {24,45,51}, { 30,40,50}
		///For which value of p ≤ 1000, is the number of solutions maximised?
		/// </summary>
		public static void p039_IntegerRightTriangles()
		{

			double res = 0;
			double count = 0;
			for ( int p = 1; p <= 1000; p++ )
			{
				int solutions_count = 0;
				for ( int a = p / 6; a < p / 2; a++ )
				{
					for ( int b = a + 1; b < ( p / 2 ); b++ )
					{
						double c = p - ( a + b );
						if ( ( a * a ) + ( b * b ) == c * c )
						{
							solutions_count++;
							//Console.WriteLine($"p: {p} ==> {{{a},{b},{c}}}");
						}
					}
				}
				count = solutions_count > res ? p : count;
				res = solutions_count > res ? solutions_count : res;

			}
			Console.ForegroundColor = ConsoleColor.Green;
			Console.WriteLine(count + " has the most solutions.");
		}

		/// <summary>
		/// PROBLEM 40.
		/// An irrational decimal fraction is created by concatenating the positive integers:
		/// 0.123456789101112131415161718192021...
		/// It can be seen that the 12th digit of the fractional part is 1.
		/// If dn represents the nth digit of the fractional part, find the value of the following expression.
		/// d1 × d10 × d100 × d1000 × d10000 × d100000 × d1000000.
		/// </summary>
		public static void p040_ChampernownesConstant()
		{

			StringBuilder st = new StringBuilder(1000000);

			int digits_count = 0;
			int z = 1;
			double end = 0;
			//find how far we need to iterate to have 1 million terms
			for ( int i = 9; i <= 99999; i = int.Parse($"{ i}9 ") )
			{
				int x = ( i.ToString().Length ) * ( i - z );
				digits_count += x;
				z *= 10;

				end = i == 99999 ? Math.Ceiling(( ( 1000000.0d - digits_count ) * ( double.Parse($"{ i}9 ") - z ) / ( ( double.Parse($"{ i}9 ") - z ) * 6.0d ) )) + z : 0;
			}

			//store sequence of terms
			for ( int i = 1; i <= end; i++ )
			{
				st.Append(i);
			}

			//get 10, 100, 1000, 10000, 1000000 term and multiply together
			int res = 1;
			for ( int i = 9; i <= 999999; i = int.Parse($"{ i}9 ") )
			{
				res *= int.Parse(st[ i ].ToString());
			}
			Console.WriteLine($"{st[ 0 ]}x{st[ 9 ]}x{st[ 99 ]}x{st[ 999 ]}x{st[ 9999 ]}x{st[ 99999 ]}x{st[ 999999 ]} ==> {res}");
		}

		/// <summary>
		/// PROBLEM 41.
		/// We shall say that an n-digit number is pandigital if it makes use of all the digits 1 to n exactly once. For example, 2143 is a 4-digit pandigital and is also prime.
		/// What is the largest n-digit pandigital prime that exists?
		/// </summary>
		public static void p041_PandigitalPrime()
		{
			List<int> nums = new List<int>(1000);
			string minus = "1111111111";
			for ( int i = 123456789; i >= 10; i -= int.Parse(minus) )
			{
				stringPermutation(i.ToString(), 0, i.ToString().Length - 1, nums);

				minus = minus.Remove(minus.Length - 1, 1);
			}
			Console.WriteLine($"Largest pandigital prime : {nums.Max()}");

		}

		/// <summary>
		/// permutation algorithm not mine (need to study it)
		/// </summary>
		/// <param name="str">string to permute</param>
		/// <param name="left">start of string</param>
		/// <param name="right">end of string</param>
		/// <param name="ls">container </param>
		private static void stringPermutation( string str, int left, int right, List<int> ls )
		{
			if ( left == right )
			{
				//Console.WriteLine(str);
				if ( CheckPrime(int.Parse(str)) )
				{
					ls.Add(int.Parse(str));
					//Console.WriteLine($"Largest pandigital prime : {str}");
					return;
				}
			}
			else
			{
				for ( int i = left; i <= right; i++ )
				{
					//swap(str[ left ], str[ i ]);
					char[] lft = str.ToCharArray();
					char c = str[ i ];
					lft[ i ] = lft[ left ];
					lft[ left ] = c;
					str = new string(lft);

					stringPermutation(str, left + 1, right, ls);
					//swap(str[ left ], str[ i ]); //swap back for backtracking
					lft = str.ToCharArray();
					c = str[ i ];
					lft[ i ] = lft[ left ];
					lft[ left ] = c;
					str = new string(lft);
				}
			}
		}

		/// <summary>
		/// PROBLEM 42.
		/// The nth term of the sequence of triangle numbers is given by, tn = ½n(n+1); so the first ten triangle numbers are:
		/// 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
		/// By converting each letter in a word to a number corresponding to its alphabetical position and adding these values we form a word value.For example, the word value for SKY is 19 + 11 + 25 = 55 = t10.If the word value is a triangle number then we shall call the word a triangle word.
		/// Using words.txt (right click and 'Save Link/Target As...'), a 16K text file containing nearly two-thousand common English words, how many are triangle words?
		/// </summary>
		public static void p042_CodedTriangleNumbers()
		{
			int res = 0;
			//end at 1300 bcoz the longest word cant be bigger than 50 letters i.e 50 * 26(the largest possible value a letter can be) == 1300)
			int[] sequence = new int[ 1300 ];
			for ( int i = 1; i < 1300; i++ )
			{
				sequence[ i ] = ( int ) ( ( 1.0 / 2.0 * i ) * ( i + 1.0 ) );
			}
			using ( StreamReader sr = new StreamReader("./p042_words.txt") )
			{
				string[] words = sr.ReadToEnd().Split(',');
				foreach ( string word in words )
				{
					int count = 0;
					foreach ( char c in word.Replace("\"", "") )
					{
						count += c - 64;//utf-8 code minus 'A' which is 64
					}
					res = sequence.Contains(count) ? res + 1 : sequence.Max() >= count ? res : -10000;
				}
			}
			Console.WriteLine($"There are {res} triangle words.");
		}

		/// <summary>
		/// PROBLEM 43.
		/// The number, 1406357289, is a 0 to 9 pandigital number because it is made up of each of the digits 0 to 9 in some order, but it also has a rather interesting sub-string divisibility property.
		/// Let d1 be the 1st digit, d2 be the 2nd digit, and so on.In this way, we note the following:
		/// d2d3d4= 406 is divisible by 2.
		/// d3d4d5= 063 is divisible by 3.
		/// d4d5d6= 635 is divisible by 5.
		/// d5d6d7= 357 is divisible by 7.
		/// d6d7d8= 572 is divisible by 11.
		/// d7d8d9= 728 is divisible by 13.
		/// d8d9d10= 289 is divisible by 17.
		/// Find the sum of all 0 to 9 pandigital numbers with this property.
		/// </summary>
		public static void p043_Sub_stringDivisibility()
		{
			List<string> PanDigits = new List<string>(3628800);
			FindPanDig0_9("0123456789", 0, 9, PanDigits);
			int[] primes = { 0, 2, 3, 5, 7, 11, 13, 17 };
			string sum = "0";
			bool passd = true;
			for ( int i = 0; i < PanDigits.Count; i++ )
			{
				passd = true;
				for ( int j = 1; j < PanDigits[ i ].Length - 2; j++ )
				{
					string substr = PanDigits[ i ].Substring(j, 3);
					if ( int.Parse(substr) % primes[ j ] != 0 )
					{
						passd = false;
						break;
					}
				}
				sum = passd ? AddLongNums(sum, PanDigits[ i ]) : sum;
			}
			Console.WriteLine($"Sum of 0 - 9 pandigital numbers: {sum}");
		}

		/// <summary>
		/// permutation algorithm not mine (need to study it)
		/// </summary>
		/// <param name="str">string to permute</param>
		/// <param name="left">start of string</param>
		/// <param name="right">end of string</param>
		/// <param name="ls">container </param>
		private static void FindPanDig0_9( string str, int left, int right, List<string> ls )
		{
			if ( left == right )
			{
				ls.Add(str);
			}
			else
			{
				for ( int i = left; i <= right; i++ )
				{
					//swap(str[ left ], str[ i ]);
					char[] lft = str.ToCharArray();
					char c = str[ i ];
					lft[ i ] = lft[ left ];
					lft[ left ] = c;
					str = new string(lft);

					FindPanDig0_9(str, left + 1, right, ls);
					//swap(str[ left ], str[ i ]); //swap back for backtracking
					lft = str.ToCharArray();
					c = str[ i ];
					lft[ i ] = lft[ left ];
					lft[ left ] = c;
					str = new string(lft);
				}
			}
		}

		/// <summary>
		/// PROBLEM 44.
		/// Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2. The first ten pentagonal numbers are:
		/// 1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
		/// It can be seen that P4 + P7 = 22 + 70 = 92 = P8.However, their difference, 70 − 22 = 48, is not pentagonal.
		/// Find the pair of pentagonal numbers, Pj and Pk, for which their sum and difference are pentagonal and D = | Pk − Pj| is minimised; what is the value of D?
		/// </summary>
		public static void p044_PentagonNumbers()
		{
			int pJ = 0;
			int pK = 0;
			int diff = 0;
			int sum = 0;
			double p = 0;
			for ( int i = 1; i < 3000; i++ )
			{
				pJ = ( i * ( ( ( 3 * i ) - 1 ) ) ) / 2;

				for ( int j = i + 1; j < 3000; j++ )
				{
					pK = ( j * ( ( ( 3 * j ) - 1 ) ) ) / 2;
					diff = pK - pJ;
					sum = pJ + pK;

					if ( isPent(diff, ref p) && isPent(sum, ref p) )//check if the sum and diff are pentagon nums
					{
						Console.WriteLine($"D is p{i}(pJ - Pk)p{j} |{pJ} - {pK}|  = {Math.Abs(pJ - pK)}");
						goto end;
					}
				}
			}
		end:
			return;
		}


		/// <summary>
		/// PROBLEM 45.
		/// Triangle, pentagonal, and hexagonal numbers are generated by the following formulae:
		/// Triangle Tn = n(n + 1) / 2	 	1, 3, 6, 10, 15, ...
		/// Pentagonal Pn = n(3n−1) / 2	 	1, 5, 12, 22, 35, ...
		/// Hexagonal Hn = n(2n−1)	 	1, 6, 15, 28, 45, ...
		/// It can be verified that T285 = P165 = H143 = 40755.
		/// Find the next triangle number that is also pentagonal and hexagonal.
		/// </summary>
		public static void p045_TriangularPentagonalHexagonal()
		{
			long T = 0;
			bool P = false;
			bool H = false;
			double h = 0;
			double p = 0;

			for ( long n = 286; ; n++ )// Tn
			{
				T = ( n * ( n + 1 ) ) / 2;//triangular num
				P = isPent(T, ref p) ? true : false;//is it a pentagonal num too
				H = P ? isHexa(T, ref h) : false;//is it hexagonal too
				if ( H )
				{
					Console.WriteLine($"T{n} = P{Math.Abs(p)} = H{Math.Abs(h)} = {Math.Abs(T)}");
					break;
				}
			}
		}

		/// <summary>
		/// Find if a number is Pentagonal.
		/// Formulae for Pentagonal number: Pn = n(3n−1) / 2.
		/// </summary>
		/// <param name="triangular">The triangular number</param>
		/// <param name="P">the resulting number</param>
		/// <returns>True if the number is a pantagonal number else False and stores 'n' in referenced int P</returns>
		private static bool isPent( long triangular, ref double P )
		{
			//use the quadratic expression to check is sum is a pantagon num
			double a = 3.0d;
			double b = -1.0d;
			double c = -( triangular * 2.0 );

			double root = Math.Sqrt(( b * b ) - ( 4 * a * c ));//quadratic equation

			//note use minus on (+ / -)
			double res = ( b - root ) / ( 2 * a );
			P = !res.ToString().Contains('.') ? res : 0;

			return !res.ToString().Contains('.');
		}

		/// <summary>
		/// Find if a number is Hexagonal.
		/// Formulae for Hexagonal numbers: Hn = n(2n−1).
		/// </summary>
		/// <param name="triangular">The triangular number</param>
		/// <param name="P">the resulting number</param>
		/// <returns>True if the number is a hexagonal number else False.</returns>
		private static bool isHexa( long triangular, ref double H )
		{
			//use the quadratic expression to check is sum is a pantagon num
			double a = 2.0d;
			double b = 1.0d;
			double c = -( triangular );

			double root = Math.Sqrt(( b * b ) - ( 4 * a * c ));

			//note use minus on (+ / -)
			double res = ( b + root ) / ( 2 * a );
			H = !res.ToString().Contains('.') ? res : 0;
			return !res.ToString().Contains('.');
		}

		/// <summary>
		/// PROBLEM 46.
		/// It was proposed by Christian Goldbach that every odd composite number can be written as the sum of a prime and twice a square.
		/// 9 = 7 + 2 × 1^2.
		/// 15 = 7 + 2 × 2^2.
		/// 21 = 3 + 2 × 3^2.
		/// 25 = 7 + 2 × 3^2.
		/// 27 = 19 + 2 × 2^2.
		/// 33 = 31 + 2 × 1^2.
		/// It turns out that the conjecture was false.
		/// What is the smallest odd composite that cannot be written as the sum of a prime and twice a square?
		/// </summary>
		public static void p046_GoldbachOtherConjecture()
		{
			int[] primes = new int[ 1000000 ];
			bool is_odd_combosite = false;
			//find odd composite numbers e.g 9 , 15 , 21 (divisible by numbers other than 1 and itself, and odd)
			for ( int i = 9; ; i++ )
			{
				is_odd_combosite = i % 2 != 0 ? !CheckPrime(i) : false;
				if ( is_odd_combosite )
				{
					for ( int j = 2; j < i; j++ )//loop prime numbers
					{
						bool pr = primes[ j ] != 0 ? true : CheckPrime(j);
						if ( pr )
						{
							primes[ j ] = j;
							int sqr = ( int ) Math.Sqrt(i);
							for ( int k = 1; k < sqr; k++ )//loop possible squares
							{
								if ( j + ( ( k * k ) * 2 ) == i )
								{
									//Console.WriteLine($"{i} = {j} + 2 x {k}^2");
									goto nxt_i;
								}
								if ( j + ( ( k * k ) * 2 ) != i && j == i - 1 && k == sqr - 1 )
								{
									Console.ForegroundColor = ConsoleColor.Green;
									Console.WriteLine($"{i} cannot be written as the sum of a prime and twice a square.");
									Console.ForegroundColor = ConsoleColor.White;
									return;
								}
							}
						}
					}

				}
				primes[ i ] = i;
			nxt_i:
				continue;
			}
		}

		/// <summary>
		/// PROBLEM 47.
		/// The first two consecutive numbers to have two distinct prime factors are:
		/// 14 = 2 × 7
		/// 15 = 3 × 5
		/// The first three consecutive numbers to have three distinct prime factors are:
		/// 644 = 2² × 7 × 23
		/// 645 = 3 × 5 × 43
		/// 646 = 2 × 17 × 19.
		/// Find the first four consecutive integers to have four distinct prime factors each.What is the first of these numbers?
		/// </summary>
		public static void p047_DistinctPrimesFactors()
		{
			int[] primes = new int[ 1001 ];
			for ( int i = 1; i <= 1000; i++ )//have at least a thousand primes (just a guess)
			{
				if ( CheckPrime(i) ) { primes[ i ] = i; }
			}

			int distinct_count = 4;
			List<int> consecutive = new List<int>(distinct_count);//store the consecutive numbers

			for ( int i = 2; ; i++ )
			{
				HashSet<int> divisors = new HashSet<int>(); //store the divisors for i
				int[] p = primes.Where(a => a <= i / 2 && a > 0).ToArray();//store prime below i
				int division_result = i;//store the division result

				//first find the prime factors of i
				for ( int n = 0; n < p.Length; )//iterate all primes below i (then divide them into i) 
				{
					if ( division_result % p[ n ] == 0 )//if prime can divide into i
					{
						divisors.Add(p[ n ]);
						division_result = division_result / p[ n ];
						if ( division_result == 1 )//if the division result is 1 (we are done finding the prime factors)
						{
							break;
						}
					}
					else { n++; }
				}

				if ( divisors.Count == distinct_count )//if has required amount of divisors 
				{
					consecutive.Add(i);
					if ( consecutive.Count == distinct_count )//if has required amount of consecutive numbers 
					{

						if ( consecutive.Max() - consecutive.Min() + 1 == consecutive.Count() )//if numbers are consecutive
						{
							foreach ( int item in consecutive )
							{
								Console.WriteLine($"{item} has {distinct_count} distinct prime factors.");
							}
							return;
						}
						else
						{
							consecutive.Clear();
						}
					}
				}
				else
				{
					consecutive.Clear();
				}
			}
		}

		/// <summary>
		/// PROBLEM 48.
		/// The series, 1^1 + 2^2 + 3^3 + ... + 10^10 = 10405071317.
		/// Find the last ten digits of the series, 1^1 + 2^2 + 3^3 + ... + 1000^1000.
		/// </summary>
		public static void p048_SelfPowers()
		{
			BigInteger res = 0;
			for ( int i = 1000; i > 0; i-- )
			{
				res += BigInteger.Pow(i, i);
			}
			string s = res.ToString();
			Console.WriteLine(s.Substring(s.Length - 10, 10));
		}

		/// <summary>
		/// PROBLEM 49.
		/// The arithmetic sequence, 1487, 4817, 8147, in which each of the terms increases by 3330, is unusual in two ways: (i) each of the three terms are prime, and, (ii) each of the 4-digit numbers are permutations of one another.
		/// There are no arithmetic sequences made up of three 1-, 2-, or 3-digit primes, exhibiting this property, but there is one other 4-digit increasing sequence.
		/// What 12-digit number do you form by concatenating the three terms in this sequence?
		/// </summary>
		public static void p049_PrimePermutations()
		{
			//find the first 1k primes
			int[] primes = new int[ 9999 ];
			for ( int i = 2; i < primes.Length; i++ )
			{
				primes[ i ] = CheckPrime(i) ? i : 0;
			}
			for ( int one = 1001; one < primes.Length; one++ )
			{
				if ( primes[ one ] == 0 )
				{
					continue;
				}
				int end = ( primes.Max() - one ) / 2;
				for ( int increment = 1; increment <= end; increment++ )
				{
					//add the possible increment value
					int two = primes[ primes[ one ] + increment ] != 0 ? primes[ primes[ one ] + increment ] : 0;
					if ( two != 0 )
					{
						int three = primes[ two + increment ] != 0 ? primes[ two + increment ] : 0;
						if ( three != 0 )//if passed means all three are prime
						{
							//check if numbers are permutes
							char[] first = one.ToString().ToCharArray().OrderBy(a => a).ToArray();
							char[] sec = two.ToString().ToCharArray().OrderBy(a => a).ToArray();
							char[] third = three.ToString().ToCharArray().OrderBy(a => a).ToArray();
							for ( int j = 0; j < 4; j++ )
							{
								if ( first[ j ] != sec[ j ] || sec[ j ] != third[ j ] )
								{
									goto next;
								}
							}
							//reaches here if above passed
							Console.WriteLine($"{one}, {two}, {three} incr({increment}) ==> {one}{two}{three}");
							goto end;
						}
					}
				next:
					continue;
				}
			end:
				continue;
			}
		}

		/// <summary>
		/// PROBLEM 50.
		/// The prime 41, can be written as the sum of six consecutive primes:
		/// 41 = 2 + 3 + 5 + 7 + 11 + 13
		/// This is the longest sum of consecutive primes that adds to a prime below one-hundred.
		/// The longest sum of consecutive primes below one-thousand that adds to a prime, contains 21 terms, and is equal to 953.
		/// Which prime, below one-million, can be written as the sum of the most consecutive primes?
		/// </summary>
		public static void p050_ConsecutivePrimeSum()
		{
			int[] res = new int[ 2 ];
			int[] primes = new int[ 1000000 ];
			//get primes below 100
			for ( int i = 0; i < primes.Length; i++ )
			{
				primes[ i ] = CheckPrime(i) ? i : 0;
			}
			int[] stripped_primes = primes.Where(a => a != 0).ToArray();//remove zeros for easy iteration

			for ( int k = 22; ; k++ )//add consecutive numbers in pairs of k till biggest sum is found
			{//k starts from 22 because we know a sum of 21-terms was found already
				for ( int i = 0; i < stripped_primes.Length; i++ )//iterate primes
				{
					int sum = 0;
					sum += stripped_primes[ i ];

					for ( int j = i; j < i + k - 1; j++ )
					{
						if ( j == stripped_primes.Length - 1 )//dont add to sum when j == number of items in array
						{
							sum = 0;
							break;
						}
						sum += stripped_primes[ j + 1 ];
					}
					if ( sum <= stripped_primes[ stripped_primes.Length - 1 ] )//if sum is less the biggest prime
					{
						if ( sum == primes[ sum ] && sum != 0 )
						{
							res[ 0 ] = sum;//save total sum
							res[ 1 ] = k;//save number of consecutive primes added
						}
					}
					else if ( i == 0 )//if k consecutive primes where added starting from i = 0 and sum > biggest prime ==> its done.
					{
						Console.Write($"{res[ 0 ]} can be written as sum of {res[ 1 ]} consecutive primes.");
						return;
					}
					else
					{
						break;//break i loop if sum > biggest prime
					}

				}
			}
		}

		/// <summary>
		/// PROBLEM 51.
		/// By replacing the 1st digit of the 2-digit number *3, it turns out that six of the nine possible values: 13, 23, 43, 53, 73, and 83, are all prime.
		/// By replacing the 3rd and 4th digits of 56**3 with the same digit, this 5-digit number is the first example having seven primes among the ten generated numbers, yielding the family: 56003, 56113, 56333, 56443, 56663, 56773, and 56993. Consequently 56003, being the first member of this family, is the smallest prime with this property.
		/// Find the smallest prime which, by replacing part of the number (not necessarily adjacent digits) with the same digit, is part of an eight prime value family.
		/// </summary>
		public static void p051_PrimeDigitReplacements()
		{
			int[] primes = new int[ 1000000 ];
			//get primes below 100
			for ( int i = 10; i < primes.Length; i++ )
			{
				primes[ i ] = CheckPrime(i) ? i : 0;
			}
			int[] stripped_primes = primes.Where(a => a != 0 && a > 1000).ToArray();//remove zeros for easy iteration
			List<int> res = new List<int>(10);

			for ( int i = stripped_primes.ToList().IndexOf(56003); i < stripped_primes.Length; i++ )
			{

				//replace 1 upto length - 1 digits
				StringBuilder num_string = new StringBuilder(stripped_primes[ i ].ToString());

				//for ( int n = num_string.Length - 1; n > 2; n-- )
				//if(num_string.Length > 3)
				//{
				int count_family = 0;
				//ALL COMMENTED CODE IS FOR REPLACING 1 & 2 DIGITS (removed for perfomance reasons)
				/*if ( n == 1 )
				{
					for ( int k = 0; k < num_string.Length; k++ )
					{
						count_family = 0;
						res.Clear();
						for ( int m = 0; m < 10; m++ )
						{
							if ( k == 0 && m == 0 ) { continue; }
							//if(m.ToString() == num_string[ k ].ToString() ) { continue; }
							StringBuilder num_temp = new StringBuilder(num_string.ToString());
							int new_num = int.Parse(num_temp.Replace(num_temp[ k ].ToString(), m.ToString(), k, n).ToString());

							count_family = primes[ new_num ] != 0 ? count_family + 1 : count_family;
							if ( primes[ new_num ] != 0 )
							{

								res.Add(new_num);
							}
						}
						if ( count_family == 8 )
						{
							Console.WriteLine($"{res[ 0 ]} is the smallest prime part of a 8 prime value family. ");
							return;
						}
					}
				}

				else if ( n == 2 )
				{

					for ( int k = 0; k < num_string.Length - 1; k++ )
					{
						for ( int l = k + 1; l < num_string.Length; l++ )
						{

							count_family = 0;
							res.Clear();

							for ( int m = 0; m < 10; m++ )
							{
								if ( k == 0 && m == 0 ) { continue; }
								//if ( m.ToString() == num_string[ k ].ToString() && m.ToString() == num_string[ l ].ToString() ) { continue; }
								StringBuilder num_temp = new StringBuilder(num_string.ToString());
								int new_num = int.Parse(num_temp.Replace(num_temp[ k ].ToString(), m.ToString(), k, 1).Replace(num_temp[ l ].ToString(), m.ToString(), l, 1).ToString());
								//int new_num = int.Parse(_num.Replace(_num[ k ].ToString(), m.ToString(), l, n).ToString());

								count_family = primes[ new_num ] != 0 ? count_family + 1 : count_family;
								if ( primes[ new_num ] != 0 )
								{

									res.Add(new_num);
								}
							}
							if ( count_family == 8 )
							{
								foreach ( int item in res )
								{
									Console.WriteLine(item);
								}
								Console.ForegroundColor = ConsoleColor.Green;

								Console.WriteLine($"{res[ 0 ]} is the smallest prime part of a 8 prime value family. ");
								return;
							}
						}
					}
				}*/
				//if ( n == 3 )
				//{

				for ( int k = 0; k < num_string.Length - 2; k++ )
				{
					for ( int l = k + 1; l < num_string.Length - 1; l++ )
					{
						for ( int p = l + 1; p < num_string.Length; p++ )
						{
							count_family = 0;
							res.Clear();

							for ( int m = 0; m < 10; m++ )
							{
								if ( k == 0 && m == 0 ) { continue; }

								StringBuilder num_temp = new StringBuilder(num_string.ToString());

								int new_num = int.Parse(num_temp.Replace(num_temp[ k ].ToString(), m.ToString(), k, 1).Replace(num_temp[ l ].ToString(), m.ToString(), l, 1).Replace(num_temp[ p ].ToString(), m.ToString(), p, 1).ToString());
								//int new_num = int.Parse(_num.Replace(_num[ k ].ToString(), m.ToString(), l, n).ToString());

								count_family = primes[ new_num ] != 0 ? count_family + 1 : count_family;
								if ( primes[ new_num ] != 0 )
								{

									res.Add(new_num);
								}
							}
							if ( count_family == 8 )
							{
								foreach ( int item in res )
								{
									Console.WriteLine(item);
								}
								Console.ForegroundColor = ConsoleColor.Green;

								Console.WriteLine($"{res[ 0 ]} is the smallest prime part of a 8 prime value family. ");
								return;
							}
						}
					}
				}
				//}

				//}
			}
		}

		/// <summary>
		/// PROBLEM 52.
		/// It can be seen that the number, 125874, and its double, 251748, contain exactly the same digits, but in a different order.
		/// Find the smallest positive integer, x, such that 2x, 3x, 4x, 5x, and 6x, contain the same digits.
		/// </summary>
		public static void p052_PermutedMultiples()
		{
			for ( int i = 125874; ; i++ )
			{
				if ( new string(i.ToString().OrderBy(a => Convert.ToInt32(a)).ToArray()) == new string(( i * 2 ).ToString().OrderBy(a => Convert.ToInt32(a)).ToArray()) )
				{
					if ( new string(( i * 2 ).ToString().OrderBy(a => Convert.ToInt32(a)).ToArray()) == new string(( i * 3 ).ToString().OrderBy(a => Convert.ToInt32(a)).ToArray()) )
					{
						if ( new string(( i * 3 ).ToString().OrderBy(a => Convert.ToInt32(a)).ToArray()) == new string(( i * 4 ).ToString().OrderBy(a => Convert.ToInt32(a)).ToArray()) )
						{
							if ( new string(( i * 4 ).ToString().OrderBy(a => Convert.ToInt32(a)).ToArray()) == new string(( i * 5 ).ToString().OrderBy(a => Convert.ToInt32(a)).ToArray()) )
							{
								if ( new string(( i * 5 ).ToString().OrderBy(a => Convert.ToInt32(a)).ToArray()) == new string(( i * 6 ).ToString().OrderBy(a => Convert.ToInt32(a)).ToArray()) )
								{
									Console.ForegroundColor = ConsoleColor.Green;
									Console.WriteLine(i);
									Console.ForegroundColor = ConsoleColor.White;
									Console.WriteLine(i * 2);
									Console.WriteLine(i * 3);
									Console.WriteLine(i * 4);
									Console.WriteLine(i * 5);
									Console.WriteLine(i * 6);
									//Console.WriteLine($"Smallest positive int containing the same digits is: {i}");
									return;
								}
							}
						}
					}
				}
			}
		}

		/// <summary>
		/// PROBLEM 53.
		/// There are exactly ten ways of selecting three from five, 12345:
		///123, 124, 125, 134, 135, 145, 234, 235, 245, and 345
		///In combinatorics, we use the notation, 
		///In general, , where, , and .
		///It is not until, that a value exceeds one-million: 
		///How many, not necessarily distinct, values of for , are greater than one-million?
		/// </summary>
		public static void p053_CombinatoricSelections()
		{
			int count = 0;
			for ( int n = 23; n <= 100; n++ )
			{
				for ( int r = 1; r <= n; r++ )
				{
					if ( FactBig(n) / ( FactBig(r) * FactBig(n - r) ) > 1000000 )
					{
						count++;
					}
				}
			}
			Console.WriteLine(count);
		}

		/// <summary>
		/// Calculate the factorial of any number. Uses BigInteger
		/// </summary>
		/// <param name="n">Number to calculate.</param>
		/// <returns>The factorial of a number: (n x n-1 x n - 2 x ... x 1).</returns>
		private static BigInteger FactBig( BigInteger n )
		{
			if ( n <= 1 ) { return 1; }
			return n * FactBig(n - 1);
		}

		/// <summary>
		/// Calculate the factorial of any number as string. 
		/// </summary>
		/// <param name="n">Number to calculate as string.</param>
		/// <returns>The factorial of a number: (n x n-1 x n - 2 x ... x 1).</returns>
		private static string FactString( string n )
		{
			if ( n == "1" || n == "0" ) { return "1"; }
			return MultiplyLongNums(n, FactString(SubLongNumbers(n, "1")));
		}

		/// <summary>
		/// [DEPRECATED] Use BigInteger instead. 
		/// Subtract big numbers.
		/// </summary>
		/// <param name="first">First number.</param>
		/// <param name="sec">Second number.</param>
		/// <returns>Subtraction of two numbers.</returns>
		private static string SubLongNumbers( string first, string sec )
		{
			string res = "";
			string big = "";
			string small = "";

			//determine   number
			if ( first.Length == sec.Length )
			{
				for ( int i = 0; i < first.Length; i++ )
				{
					if ( first[ i ] > sec[ i ] )
					{
						big = first;
						small = sec;
						break;
					}
					else if ( first[ i ] < sec[ i ] )
					{
						big = sec;
						small = first;
						break;
					}
					else
					{
						if ( i == first.Length - 1 )//numbers are the same
						{
							big = first;
							small = sec;
							break;
						}
					}
				}
			}
			else
			{
				big = first.Length > sec.Length ? first : sec;
				for ( int i = 0; i < Math.Max(first.Length, sec.Length) - Math.Min(first.Length, sec.Length); i++ )
				{
					small += "0";
				}
				small += first.Length < sec.Length ? first : sec;
			}

			string[] bg = Array.ConvertAll(big.ToArray(), a => a.ToString());
			string[] sml = Array.ConvertAll(small.ToArray(), a => a.ToString());

			//int carry = 0;
			for ( int i = bg.Length - 1; i >= 0; i-- )
			{


				res += int.Parse(bg[ i ]) < int.Parse(sml[ i ]) ? ( Convert.ToInt32(bg[ i ]) + 10 ) - Convert.ToInt32(sml[ i ]) : Convert.ToInt32(bg[ i ]) - Convert.ToInt32(sml[ i ]);
				if ( i > 0 && int.Parse(bg[ i ]) < int.Parse(sml[ i ]) )
				{

					sml[ i - 1 ] = int.Parse(bg[ i ]) < int.Parse(sml[ i ]) ? ( 1 + Convert.ToInt32(sml[ i - 1 ]) ).ToString() : "0";
				}
			}
			res = new string(res.Reverse().ToArray());
			while ( res.ElementAt(0) == '0' )
			{

				res = res.Remove(0, 1);
			}

			return res;
		}

		/// <summary>
		/// PROBLEM 54.
		/// The file, poker.txt, contains one-thousand random hands dealt to two players. Each line of the file contains ten cards (separated by a single space): the first five are Player 1's cards and the last five are Player 2's cards. You can assume that all hands are valid (no invalid characters or repeated cards), each player's hand is in no specific order, and in each hand there is a clear winner.
		/// How many hands does Player 1 win?
		/// </summary>
		public static void p054_PokerHands()
		{
			string[] hands = new string[ 2 ];
			string s = null;
			int player1_wins = 0;
			string cards_seq = "23456789TJQKA";
			using ( StreamReader sr = new StreamReader("./p054_poker.txt") )
			{
				while ( ( s = sr.ReadLine() ) != null )
				{
					hands[ 0 ] = s.Replace(" ", "").Substring(0, 10);
					hands[ 1 ] = s.Replace(" ", "").Substring(10, 10);

					int p1_hands_points = CheckHand(hands[ 0 ]);
					int p2_hands_points = CheckHand(hands[ 1 ]);

					if ( p1_hands_points > p2_hands_points )
					{
						player1_wins++;

					}
					else if ( p1_hands_points == p2_hands_points )
					{
						if ( p1_hands_points < 0 )
						{
							string h1 = "";
							string h2 = "";
							//check for hand with big values
							for ( int i = cards_seq.Length - 1; i >= 0; i-- )
							{
								h1 = hands[ 0 ].Contains(cards_seq[ i ]) ? h1 + cards_seq[ i ] : h1;
								h2 = hands[ 1 ].Contains(cards_seq[ i ]) ? h2 + cards_seq[ i ] : h2;
							}

							for ( int j = 0; j < h1.Length; j++ )
							{
								if ( cards_seq.IndexOf(h1[ j ]) > cards_seq.IndexOf(h2[ j ]) )//player 1 has high card
								{
									player1_wins++;

									goto end;
								}
								else if ( cards_seq.IndexOf(h2[ j ]) > cards_seq.IndexOf(h1[ j ]) )//player 2 has high card
								{

									goto end;
								}
							}
						}
						else
						{
							string p1 = hands[ 0 ];//player 1
							for ( int i = 1; i < p1.Length; i++ )
							{
								p1 = p1.Remove(i, 1);//remove suits
							}

							string p2 = hands[ 1 ];//player 2
							for ( int i = 1; i < p2.Length; i++ )
							{
								p2 = p2.Remove(i, 1);//remove suits
							}

							for ( int k = cards_seq.Length - 1; k >= 0; k-- )
							{
								char suit = cards_seq[ k ];

								//check higher straight flush (all cards are consecutive values in same suit)
								if ( p1_hands_points == 9 )
								{
									if ( p1.Contains(suit) && !p2.Contains(suit) )
									{

										player1_wins++;
										goto end;
									}
									else if ( !p1.Contains(suit) && p2.Contains(suit) )
									{

										goto end;
									}
								}

								//check higher 4 of a kind
								else if ( p1_hands_points == 8 )
								{
									if ( p1.Count(a => a == suit) == 4 )
									{
										if ( p2.Count(a => a == suit) == 4 )
										{
											p1 = p1.Replace(suit.ToString(), "");
											p2 = p2.Replace(suit.ToString(), "");
											if ( cards_seq.IndexOf(p1[ 0 ]) > cards_seq.IndexOf(p2[ 0 ]) )
											{
												player1_wins++;

												goto end;
											}
											else
											{

												goto end;
											}
										}
										else
										{
											player1_wins++;

											goto end;
										}

									}
									else if ( p2.Count(a => a == suit) == 4 )
									{

										goto end;
									}
								}

								//check higher full house (three of a kind and a pair)
								else if ( p1_hands_points == 7 )
								{
									if ( p1.Count(a => a == suit) == 3 )
									{
										if ( p2.Count(a => a == suit) == 3 )//they have same 3 of a kind
										{
											//check 2 of a kind
											p2 = p2.Replace(suit.ToString(), "");
											p1 = p1.Replace(suit.ToString(), "");
											if ( p1[ 0 ] > p2[ 0 ] )
											{

												player1_wins++;
												goto end;
											}
										}
										else
										{

											player1_wins++;
											goto end;
										}
									}
									else if ( p2.Count(a => a == suit) == 3 )
									{

										goto end;
									}
								}

								//check higher flush (all cards of the same suit)
								else if ( p1_hands_points == 6 )
								{
									if ( p1.Contains(suit) && !p2.Contains(suit) )
									{

										player1_wins++;
										goto end;
									}
									else if ( !p1.Contains(suit) && p2.Contains(suit) )
									{

										goto end;
									}
								}

								//check higher straight (all cards are consecutive values)
								else if ( p1_hands_points == 5 )
								{
									if ( p1.Contains(suit) && !p2.Contains(suit) )
									{

										player1_wins++;
										goto end;
									}
									else if ( !p1.Contains(suit) && p2.Contains(suit) )
									{

										goto end;
									}
								}

								//check higher three of a kind )
								else if ( p1_hands_points == 4 )
								{
									if ( p1.Count(a => a == suit) == 3 )
									{
										if ( p2.Count(a => a == suit) == 3 )
										{
											//check high card
											p1 = p1.Replace(suit.ToString(), "");
											p2 = p2.Replace(suit.ToString(), "");
											if ( cards_seq.IndexOf(p1[ 0 ]) > cards_seq.IndexOf(p2[ 0 ]) || cards_seq.IndexOf(p1[ 0 ]) > cards_seq.IndexOf(p2[ 1 ]) )
											{

												player1_wins++;
												goto end;
											}
											else if ( cards_seq.IndexOf(p1[ 1 ]) > cards_seq.IndexOf(p2[ 0 ]) || cards_seq.IndexOf(p1[ 1 ]) > cards_seq.IndexOf(p2[ 1 ]) )
											{

												player1_wins++;
												goto end;
											}
										}
										else
										{

											player1_wins++;
											goto end;
										}
									}
									else if ( p2.Count(a => a == suit) == 3 )
									{

										goto end;
									}
								}

								//check higher 2 pairs
								else if ( p1_hands_points == 3 )
								{
									if ( p1.Count(a => a == suit) == 2 && p2.Count(a => a == suit) != 2 )
									{
										player1_wins++;

										goto end;
									}
									else if ( p2.Count(a => a == suit) == 2 && p1.Count(a => a == suit) != 2 )
									{

										goto end;
									}
									else if ( p2.Count(a => a == suit) == 2 && p1.Count(a => a == suit) == 2 )
									{
										p1 = p1.Replace(suit.ToString(), "");
										p2 = p2.Replace(suit.ToString(), "");

										for ( int i = cards_seq.IndexOf(suit) - 1; i >= 0; i-- )
										{
											char st = cards_seq[ i ];
											if ( p1.Count(a => a == st) == 2 && p2.Count(a => a == st) != 2 )
											{
												player1_wins++;

												goto end;
											}
											else if ( p2.Count(a => a == st) == 2 && p1.Count(a => a == st) != 2 )
											{

												goto end;
											}
											else if ( p2.Count(a => a == st) == 2 && p1.Count(a => a == st) == 2 )
											{
												p1 = p1.Replace(st.ToString(), "");
												p2 = p2.Replace(st.ToString(), "");
												if ( cards_seq.IndexOf(p1[ 0 ]) > cards_seq.IndexOf(p2[ 0 ]) )
												{
													player1_wins++;

													goto end;
												}
												else if ( cards_seq.IndexOf(p1[ 0 ]) < cards_seq.IndexOf(p2[ 0 ]) )
												{

													goto end;
												}
												else goto end;
											}
										}
									}
								}

								//check higher 1 pairs
								else if ( p1_hands_points == 2 )
								{
									if ( p1.Count(a => a == suit) == 2 )
									{
										if ( p2.Count(a => a == suit) == 2 )
										{
											p1 = p1.Replace(suit.ToString(), "");
											p2 = p2.Replace(suit.ToString(), "");
											for ( int i = cards_seq.Length - 1; i >= 0; i-- )
											{
												if ( p1.Contains(cards_seq[ i ]) && !p2.Contains(cards_seq[ i ]) )
												{

													player1_wins++;
													goto end;
												}
												if ( p2.Contains(cards_seq[ i ]) && !p1.Contains(cards_seq[ i ]) )
												{

													goto end;
												}
											}
										}
										else
										{

											player1_wins++;
											goto end;
										}
									}
									else if ( p2.Count(a => a == suit) == 2 )
									{

										goto end;
									}
								}

							}


						}
					}
					else
					{

					}
				end:
					continue;
				}
			}
			Console.ForegroundColor = ConsoleColor.Green;
			Console.WriteLine("Player 1 won {0} hands.", player1_wins);
			Console.ForegroundColor = ConsoleColor.White;
		}

		/// <summary>
		/// Determines what a given hand in a game of poker is.
		/// </summary>
		/// <param name="hand">The string of the five cards separarted by a single space eg "AD TH 2S 2C QD".</param>
		/// <returns>Score between 10 to 2 or -1 to -13, positive score is One Pair - Royal Flush, nagative score is a High Card (-1 for Ace, -13 for 2). </returns>
		private static int CheckHand( string hand )
		{
			//int points = 0;
			string cards_seq = "23456789TJQKA";

			//check same suit
			if ( hand.Count(a => a == 'H') == 5 || hand.Count(a => a == 'D') == 5 || hand.Count(a => a == 'S') == 5 || hand.Count(a => a == 'C') == 5 )//if same suit
			{
				//check royal flush
				if ( hand.TakeWhile(a => a > 57).Sum(b => b) == 'T' + 'J' + 'Q' + 'K' + 'A' )
				{
					return 10;//royal flush (Ten - Ace in same suit)
				}

				//check straight flush
				string p1_ = new string(hand.Replace(hand[ 1 ].ToString(), "").ToArray());
				string p1_hand = string.Empty;
				for ( int i = 0; i < cards_seq.Length; i++ )
				{
					int c = hand.Count(a => a == cards_seq[ i ]);
					for ( int j = 0; j < c; j++ )
					{
						p1_hand += cards_seq[ i ];
					}
				}
				int index = cards_seq.IndexOf(p1_hand[ 0 ]);
				int count = 13 - index >= 5 ? 5 : 13 - index;
				string compare = cards_seq.Substring(index, count);
				if ( p1_hand == compare )
				{
					return 9;//straight flush (all cards are consecutive values of same suit)
				}

				return 6;//flush (all cards of the same suit)
			}
			else
			{
				string p1_hand = string.Empty;
				for ( int i = 0; i < cards_seq.Length; i++ )
				{
					int c = hand.Count(a => a == cards_seq[ i ]);
					for ( int j = 0; j < c; j++ )
					{
						p1_hand += cards_seq[ i ];
					}
				}
				int index = cards_seq.IndexOf(p1_hand[ 0 ]);
				int count = 13 - index >= 5 ? 5 : 13 - index;
				string compare = cards_seq.Substring(index, count);
				if ( p1_hand == compare )
				{
					return 5;//straight (all cards are consecutive values)
				}

				//check others
				for ( int k = cards_seq.Length - 1; k >= 0; k-- )
				{
					char suit = cards_seq[ k ];
					if ( p1_hand.Count(a => a == suit) == 4 )
					{
						return 8;//four of a kind (4 cards of same value)
					}
				}

				for ( int k = cards_seq.Length - 1; k >= 0; k-- )
				{
					char suit = cards_seq[ k ];

					if ( p1_hand.Count(a => a == suit) == 3 )
					{
						//check if theres a pair
						string new_p1 = p1_hand.Replace(suit.ToString(), "");
						if ( new_p1[ 0 ] == new_p1[ 1 ] )
						{
							return 7;//full house (three of a kind and a pair)
						}
						return 4;// 3 of kind
					}
				}

				for ( int k = cards_seq.Length - 1; k >= 0; k-- )
				{
					char suit = cards_seq[ k ];
					if ( p1_hand.Count(a => a == suit) == 2 )
					{
						string new_p1 = p1_hand.Replace(suit.ToString(), "");
						if ( new_p1.Count(a => a == new_p1[ 0 ]) == 2 )
						{
							return 3; //two pairs
						}
						else if ( new_p1.Count(a => a == new_p1[ 1 ]) == 2 )
						{
							return 3; //two pairs
						}
						return 2; //one pair (2 card of the same value)
					}
				}
				//check high card
				for ( int i = cards_seq.Length - 1; i >= 0; i-- )
				{
					if ( hand.Contains(cards_seq[ i ]) )
					{
						return i - 13;
					}
				}
			}
			return 0;
		}

		/// <summary>
		/// PROBLEM 55.
		/// If we take 47, reverse and add, 47 + 74 = 121, which is palindromic.
		/// Not all numbers produce palindromes so quickly.For example,
		///		349 + 943 = 1292,
		///		1292 + 2921 = 4213
		///		4213 + 3124 = 7337
		/// That is, 349 took three iterations to arrive at a palindrome.
		/// Although no one has proved it yet, it is thought that some numbers, like 196, never produce a palindrome. A number that never forms a palindrome through the reverse and add process is called a Lychrel number. Due to the theoretical nature of these numbers, and for the purpose of this problem, we shall assume that a number is Lychrel until proven otherwise. In addition you are given that for every number below ten-thousand, it will either (i) become a palindrome in less than fifty iterations, or, (ii) no one, with all the computing power that exists, has managed so far to map it to a palindrome. In fact, 10677 is the first number to be shown to require over fifty iterations before producing a palindrome: 4668731596684224866951378664 (53 iterations, 28-digits).
		/// Surprisingly, there are palindromic numbers that are themselves Lychrel numbers; the first example is 4994.
		/// How many Lychrel numbers are there below ten-thousand?
		/// </summary>
		public static void p055_LychrelNumbers()
		{
			int lychrel = 0;
			for ( int i = 11; i < 10000; i++ )//take a number
			{
				int iterations = 1;
				//reverse i
				BigInteger reverse = BigInteger.Parse(new string(i.ToString().Reverse().ToArray()));
				//add i and reverse number
				BigInteger sum = i + reverse;
				//check if sum is a palindrome
				reverse = BigInteger.Parse(new string(sum.ToString().Reverse().ToArray()));

				while ( sum != reverse )//while not palindrome
				{
					if ( iterations == 50 )
					{
						lychrel++;
						break;
					}
					sum = sum + reverse;
					reverse = BigInteger.Parse(new string(sum.ToString().Reverse().ToArray()));
					iterations++;
				}
			}
			Console.WriteLine($"There are {lychrel} lychrel numbers below  ten-thousand.");
		}

		/// <summary>
		/// PROBLEM 56.
		/// A googol (10^100) is a massive number: one followed by one-hundred zeros; 100^100 is almost unimaginably large: one followed by two-hundred zeros. Despite their size, the sum of the digits in each number is only 1.
		/// Considering natural numbers of the form, a^b, where a, b< 100, what is the maximum digital sum?
		/// </summary>
		public static void p056_PowerfulDigitSum()
		{
			BigInteger x;
			int max_sum = 0;
			int sum = 0;
			for ( int i = 1; i < 100; i++ )
			{
				for ( int j = 0; j < 100; j++ )
				{
					x = BigInteger.Pow(i, j);
					sum = x.ToString().Sum(a => int.Parse(a.ToString()));
					max_sum = sum > max_sum ? sum : max_sum;
				}
			}
			Console.WriteLine(max_sum);
		}

		/// <summary>
		/// PROBLEM 57.
		/// It is possible to show that the square root of two can be expressed as an infinite continued fraction.
		/// By expanding this for the first four iterations, we get:
		/// but the eighth expansion, is the first example where the number of digits in the numerator exceeds the number of digits in the denominator.
		/// In the first one-thousand expansions, how many fractions contain a numerator with more digits than the denominator?
		/// </summary>
		public static void p057_SquareRootConvergents()
		{
			//double prev = 1.0 / 2.0 ;
			//for ( int i = 2; i <= 1000; i++ )
			//{
			//	double x = 2.0 + prev;
			//	prev = 1.0 / x;
			//	double calc = prev + 1.0;
			//	Console.WriteLine($"iteration #{i}: {calc} ==> ");
			//}
			BigInteger count = 0;
			BigInteger n = 3;
			BigInteger d = 2;
			for ( int i = 1; i < 1000; i++ )
			{
				n = n + 2 * d;
				d = n - d;
				count = n.ToString().Length > d.ToString().Length ? count + 1 : count;
			}
			Console.WriteLine(count);
		}

		/// <summary>
		/// PROBLEM 58.
		/// Starting with 1 and spiralling anticlockwise in the following way, a square spiral with side length 7 is formed.
		/// 37 36 35 34 33 32 31
		/// 38 17 16 15 14 13 30
		/// 39 18  5  4  3 12 29
		/// 40 19  6  1  2 11 28
		/// 41 20  7  8  9 10 27
		/// 42 21 22 23 24 25 26
		/// 43 44 45 46 47 48 49
		/// It is interesting to note that the odd squares lie along the bottom right diagonal, but what is more interesting is that 8 out of the 13 numbers lying along both diagonals are prime; that is, a ratio of 8/13 ≈ 62%.
		/// If one complete new layer is wrapped around the spiral above, a square spiral with side length 9 will be formed.If this process is continued, what is the side length of the square spiral for which the ratio of primes along both diagonals first falls below 10%?
		/// </summary>
		public static void p058_SpiralPrimes()
		{

			float res = 0;

			float dia_count = 0;
			float dia_prime = 0.0f;

			int center = 1;
			int adder = 2;
			int counter = 0;
			while ( true )
			{
				center = center + adder;
				dia_prime = CheckPrime(center) ? dia_prime + 1 : dia_prime;

				counter++;
				adder = counter == 4 ? adder + 2 : adder;
				dia_count = counter == 4 ? ( float ) ( Math.Sqrt(center) * 2 ) - 1 : dia_count;
				counter = counter == 4 ? 0 : counter;

				res = ( dia_prime / dia_count ) * 100;
				if ( res <= 10 )
				{
					double grid = Math.Sqrt(center);
					Console.WriteLine($"a {grid} x {grid} grid has {res}% prime numbers");
					break;
				}
			}

		}

		/// <summary>
		/// PROBLEM 59.
		/// Each character on a computer is assigned a unique code and the preferred standard is ASCII (American Standard Code for Information Interchange). For example, uppercase A = 65, asterisk (*) = 42, and lowercase k = 107.
		/// A modern encryption method is to take a text file, convert the bytes to ASCII, then XOR each byte with a given value, taken from a secret key.The advantage with the XOR function is that using the same encryption key on the cipher text, restores the plain text; for example, 65 XOR 42 = 107, then 107 XOR 42 = 65.
		/// For unbreakable encryption, the key is the same length as the plain text message, and the key is made up of random bytes.The user would keep the encrypted message and the encryption key in different locations, and without both "halves", it is impossible to decrypt the message.
		/// Unfortunately, this method is impractical for most users, so the modified method is to use a password as a key. If the password is shorter than the message, which is likely, the key is repeated cyclically throughout the message.The balance for this method is using a sufficiently long password key for security, but short enough to be memorable.
		/// Your task has been made easy, as the encryption key consists of three lower case characters.Using p059_cipher.txt( right click and 'Save Link/Target As...'), a file containing the encrypted ASCII codes, and the knowledge that the plain text must contain common English words, decrypt the message and find the sum of the ASCII values in the original text.
		/// </summary>
		public static void p059_XORDecryption()
		{
			using ( StreamReader sr = new StreamReader("p059_cipher.txt") )
			{
				int[] cipher = Array.ConvertAll(sr.ReadToEnd().Split(','), a => int.Parse(a));//text to be decrypted
				string alphabet = "abcdefghijklmnopqrstuvwxyz";
				List<string> keys = new List<string>(7);//for storing key permutations
				string found = string.Empty;

				//generate combinations in 3s then permute those combinations
				for ( int i = 0; i < alphabet.Length - 2; i++ )
				{
					for ( int j = i + 1; j < alphabet.Length - 1; j++ )
					{
						for ( int k = j + 1; k < alphabet.Length; k++ )
						{
							Permutation($"{alphabet[ i ]}{alphabet[ j ]}{alphabet[ k ]}", 0, 2, keys);//permutation of the combination
							foreach ( string key in keys )
							{
								string sb = "";
								int count = 0;//for repeating key cyclically
								foreach ( int letter in cipher )
								{
									sb += char.ConvertFromUtf32(letter ^ key[ count ]);//xor cipher text with possible key
									count++;
									count = count == 3 ? 0 : count;
								}

								if ( sb.Contains(" the ") )
								{
									found = sb;
									Console.WriteLine(sb);
									Console.ForegroundColor = ConsoleColor.Green;
									Console.WriteLine($"key = {key}");
									Console.ForegroundColor = ConsoleColor.White;
									goto end;
								}

							}
							keys.Clear();
						}
					}
				}
			end:
				Console.WriteLine(found.ToCharArray().Sum(a => a));
			}
		}
		private static void Permutation( string str, int left, int right, List<string> res )
		{
			if ( left == right )
			{
				res.Add(str);
			}
			else
			{
				for ( int i = left; i <= right; i++ )
				{
					//swap(str[ left ], str[ i ]);
					char[] lft = str.ToCharArray();
					char c = str[ i ];
					lft[ i ] = lft[ left ];
					lft[ left ] = c;
					str = new string(lft);

					Permutation(str, left + 1, right, res);
					//swap(str[ left ], str[ i ]); //swap back for backtracking
					lft = str.ToCharArray();
					c = str[ i ];
					lft[ i ] = lft[ left ];
					lft[ left ] = c;
					str = new string(lft);
				}
			}
		}

		private static void Permutation( string str, int left, int right, HashSet<ulong> res, string original_number, string n )
		{
			if ( left == right )
			{
				//ulong i = ulong.Parse(str);
				if (str[0] >= original_number[0] &&  Math.Pow(ulong.Parse(str), ( double ) 1 / 3).ToString().Length == n.Length ){

					res.Add(ulong.Parse(str));
				}
			}
			else
			{
				for ( int i = left; i <= right; i++ )
				{
					//swap(str[ left ], str[ i ]);
					char[] lft = str.ToCharArray();
					char c = str[ i ];
					lft[ i ] = lft[ left ];
					lft[ left ] = c;
					str = new string(lft);

					Permutation(str, left + 1, right, res, original_number, n);
					//swap(str[ left ], str[ i ]); //swap back for backtracking
					lft = str.ToCharArray();
					c = str[ i ];
					lft[ i ] = lft[ left ];
					lft[ left ] = c;
					str = new string(lft);
				}
			}
		}

		/// <summary>
		/// PROBLEM 60.
		/// The primes 3, 7, 109, and 673, are quite remarkable. By taking any two primes and concatenating them in any order the result will always be prime. For example, taking 7 and 109, both 7109 and 1097 are prime. The sum of these four primes, 792, represents the lowest sum for a set of four primes with this property.

		/// Find the lowest sum for a set of five primes for which any two primes concatenate to produce another prime.
		/// </summary>
		public static void p060_PrimePairSets()
		{

			//get primes
			List<int> primes = new List<int>();
			int[] mapped_primes = new int[ 1000000 ];
			for ( int i = 0; i < 10000; i++ )
			{
				if ( CheckPrime(i) )
				{
					primes.Add(i);
					mapped_primes[ i ] = i;
				}
			}
			for ( int i = 10001; i < 1000000; i++ )
			{
				if ( CheckPrime(i) )
				{
					mapped_primes[ i ] = i;
				}
			}

			int concat1, concat2 = 0;
			int[] five = new int[ 5 ];

			for ( int a = 0; a < primes.Count - 3; a++ )
			{
				for ( int b = a + 1; b < primes.Count - 2; b++ )
				{
					concat1 = int.Parse($"{primes[ a ]}{primes[ b ]}");
					concat2 = int.Parse($"{primes[ b ]}{primes[ a ]}");

					if ( concat1 < 1000000 && concat2 < 1000000 )
					{
						if ( mapped_primes[ concat1 ] != concat1 || mapped_primes[ concat2 ] != concat2 )
						{
							continue;//failed check next
						}

					}
					else if ( !CheckPrime(concat1) || !CheckPrime(concat2) )
					{
						continue;//failed check next
					}

					for ( int c = b + 1; c < primes.Count - 1; c++ )
					{
						concat1 = int.Parse($"{primes[ b ]}{primes[ c ]}");
						concat2 = int.Parse($"{primes[ c ]}{primes[ b ]}");

						if ( concat1 < 1000000 && concat2 < 1000000 )
						{
							if ( mapped_primes[ concat1 ] != concat1 || mapped_primes[ concat2 ] != concat2 )
							{
								continue;//failed check next
							}

						}
						else if ( !CheckPrime(concat1) || !CheckPrime(concat2) )
						{
							continue;//failed check next
						}

						for ( int d = c + 1; d < primes.Count; d++ )
						{
							concat1 = int.Parse($"{primes[ c ]}{primes[ d ]}");
							concat2 = int.Parse($"{primes[ d ]}{primes[ c ]}");

							if ( concat1 < 1000000 && concat2 < 1000000 )
							{
								if ( mapped_primes[ concat1 ] != concat1 || mapped_primes[ concat2 ] != concat2 )
								{
									continue;//failed check next
								}

							}
							else if ( !CheckPrime(concat1) || !CheckPrime(concat2) )
							{
								continue;//failed check next
							}

							five[ 0 ] = primes[ a ];
							five[ 1 ] = primes[ b ];
							five[ 2 ] = primes[ c ];
							five[ 3 ] = primes[ d ];

							//checking if the 4 numbers concact and still produce a prime
							for ( int i = 0; i < five.Length - 1; i++ )
							{
								for ( int j = i + 2; j < five.Length - 1; j++ )
								{
									//if ( i == j ) { continue; }
									concat1 = int.Parse($"{five[ i ]}{five[ j ]}");
									concat2 = int.Parse($"{five[ j ]}{five[ i ]}");
									if ( concat1 < 1000000 && concat2 < 1000000 )
									{
										if ( mapped_primes[ concat1 ] != concat1 || mapped_primes[ concat2 ] != concat2 )
										{
											goto nxt;//failed check next
										}
									}
									else if ( !CheckPrime(concat1) || !CheckPrime(concat2) )
									{
										goto nxt;//failed check next
									}
								}
							}

							//find the fifth prime
							for ( int i = primes.IndexOf(primes[ d ]) + 1; i < primes.Count; i++ )
							{
								five[ 4 ] = primes[ i ];
								//concat posible 5 primes 
								for ( int k = 0; k < five.Length - 1; k++ )
								{
									concat1 = int.Parse($"{five[ k ]}{five[ 4 ]}");
									concat2 = int.Parse($"{five[ 4 ]}{five[ k ]}");
									if ( concat1 < 1000000 && concat2 < 1000000 )
									{
										if ( mapped_primes[ concat1 ] != concat1 || mapped_primes[ concat2 ] != concat2 )
										{
											goto nxts;//failed check next
										}
									}
									else if ( !CheckPrime(concat1) || !CheckPrime(concat2) )
									{
										goto nxts;//failed check next
									}
								}
								//quit if five primes are found
								goto end;

							nxts:
								continue;
							}
						nxt:
							continue;
						}
					}
				}
			}
		end:
			Console.WriteLine($"Five primes are: {five[ 0 ]}, {five[ 1 ]}, {five[ 2 ]}, {five[ 3 ]}, {five[ 4 ]}");
			Console.WriteLine($"Sum of primes: {five.Sum()}");
		}

		/// <summary>
		/// PROBLEM 61.
		/// Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal numbers are all figurate (polygonal) numbers and are generated by the following formulae:

		/// Triangle P3, n = n(n + 1) / 2	 	1, 3, 6, 10, 15, ...
		/// Square P4, n = n2	 	1, 4, 9, 16, 25, ...
		/// Pentagonal P5, n = n(3n−1) / 2	 	1, 5, 12, 22, 35, ...
		/// Hexagonal P6, n = n(2n−1)	 	1, 6, 15, 28, 45, ...
		/// Heptagonal P7, n = n(5n−3) / 2	 	1, 7, 18, 34, 55, ...
		/// Octagonal P8, n = n(3n−2)	 	1, 8, 21, 40, 65, ...
		/// The ordered set of three 4-digit numbers: 8128, 2882, 8281, has three interesting properties.

		/// The set is cyclic, in that the last two digits of each number is the first two digits of the next number( including the last number with the first).
		/// Each polygonal type: triangle( P3,127=8128), square( P4,91=8281), and pentagonal( P5,44=2882), is represented by a different number in the set.
		/// This is the only set of 4-digit numbers with this property.
		/// Find the sum of the only ordered set of six cyclic 4-digit numbers for which each polygonal type: triangle, square, pentagonal, hexagonal, heptagonal, and octagonal, is represented by a different number in the set.
		/// </summary>
		public static void p061_CyclicalFigurateNumbers()
		{
			string tri, sqr, pent, hex, hept, oct = String.Empty;
			string[] container = new string[6];
			HashSet<string> validator1 = new HashSet<string>();
			HashSet<string> validator2 = new HashSet<string>();

			for ( int a = 45; a <= 140; a++ )
			{
				//triangle
				tri = ( ( a * ( a + 1 ) ) / 2 ).ToString();
				container[ 0 ] = tri;

				for ( int b = 32; b <= 99; b++ )
				{
					//square
					sqr = ( b * b ).ToString();
					container[ 1 ] = sqr;

					for ( int c = 26; c <= 81; c++ )
					{
						//pentagonal
						pent = ( ( c * ( ( 3 * c ) - 1 ) ) / 2 ).ToString();
						container[ 2 ] = pent;

						foreach ( string value in container )
						{
							if ( value != null )
							{
								validator1.Add(value.Substring(0, 2));
								validator2.Add(value.Substring(2, 2));
							}
						}
						validator1.IntersectWith(validator2);
						if ( validator1.Count != 3 )
						{
							validator1.Clear();
							validator2.Clear();
							continue;
						}

						for ( int d = 23; d <= 70; d++ )
						{
							//hexagonal
							hex = (d * ((d * 2) - 1) ).ToString();
							container[ 3 ] = hex;

							for ( int e = 21; e <= 63; e++ )
								{
								//heptagonal
								hept = ( ( e * ( ( 5 * e ) - 3 ) ) / 2 ).ToString();
								container[ 4 ] = hept;

								for ( int f = 19; f <= 58; f++ )
								{
									//octagonal
									oct = (  f * ( ( 3 * f ) - 2 ) ).ToString();
									container[ 5 ] = oct;

									foreach ( string value in container )
									{
										if( value.Substring(0, 2)  == value.Substring(2, 2) )
										{
											goto nxt;
										}
										validator1.Add(value.Substring(0, 2));
										validator2.Add(value.Substring(2, 2));
									}
									validator1.IntersectWith(validator2);
									if ( validator1.Count == 6 )
									{
										Console.WriteLine($"P3,{a} = {tri}");
										Console.WriteLine($"P4,{b} = {sqr}");
										Console.WriteLine($"P5,{c} = {pent}");
										Console.WriteLine($"P6,{d} = {hex}");
										Console.WriteLine($"P7,{e} = {hept}");
										Console.WriteLine($"P8,{f} = {oct}");
										Console.WriteLine($"sum: {Array.ConvertAll(new string[] { tri, sqr, pent, hex, hept, oct }, num => int.Parse(num)).Sum()}");
										goto end;
									}
									nxt:
									validator1.Clear();
									validator2.Clear();
								}
							}
						}
						
					}
				}
			}
			end:
			Console.WriteLine();
		}

		/// <summary>
		/// PROBLEM 62.
		/// The cube, 41063625 (3453), can be permuted to produce two other cubes: 56623104 (3843) and 66430125 (4053). In fact, 41063625 is the smallest cube which has exactly three permutations of its digits which are also cube.
		/// Find the smallest cube for which exactly five permutations of its digits are cube.
		/// </summary>
		public static void p062_CubicPermutations()
		{
			string cube1,cube2,cube3,cube4,cube5 = "";
			for ( BigInteger i = 5000;  ; i++ )
			{
				cube1 = new string(( i * i * i ).ToString().OrderBy(a => a).ToArray());
				for ( BigInteger j = i+1; ; j++ )
				{
					cube2 = new string(( j * j * j ).ToString().OrderBy(a => a).ToArray());
					if(cube2.Length > cube1.Length ) { break; }
					if(cube1 == cube2 )
					{
						for ( BigInteger k = j+1;  ; k++ )
						{
							cube3 = new string(( k * k * k ).ToString().OrderBy(a => a).ToArray());
							if(cube3.Length > cube1.Length ) { break; }
							if(cube2 == cube3 )
							{
								for ( BigInteger l = k+1; ; l++ )
								{
									cube4 = new string(( l * l * l ).ToString().OrderBy(a => a).ToArray());
									if ( cube4.Length > cube1.Length ) { break; }
									if ( cube3 == cube4 )
									{
										for ( BigInteger m = l + 1; ; m ++ )
										{
											cube5 = new string(( m * m * m ).ToString().OrderBy(a => a).ToArray());
											if ( cube5.Length > cube1.Length ) { break; }
											if ( cube4 == cube5 )
											{
												Console.WriteLine($"{i}^3 ==> {i * i * i}");
												Console.WriteLine($"{j}^3 ==> {j * j * j}");
												Console.WriteLine($"{k}^3 ==> {k * k * k}");
												Console.WriteLine($"{l}^3 ==> {l * l * l}");
												Console.WriteLine($"{m}^3 ==> {m * m * m}");
												goto end;
											}
										}
									}
								}
							}
						}
					}
				}
			}
			end:
			Console.WriteLine();
		}

		/// <summary>
		/// PROBLEM 63.
		/// The 5-digit number, 16807=75, is also a fifth power. Similarly, the 9-digit number, 134217728=89, is a ninth power.
		/// How many n-digit positive integers exist which are also an nth power?
		/// </summary>
		public static void p063_PowerfulDigitCounts()
		{
			BigInteger res = 0;
			int count = 0;
			for ( int bas = 1; bas <= 10; bas++ )
			{
				for ( int exp = 1; exp <= 50; exp++ )
				{

					res = BigInteger.Pow(bas, exp) ;
					if( res.ToString().Length == exp )
					{
						count++;
						//Console.WriteLine($"{bas} ^ {exp} = {res}");
					}
					
				}
			}
			Console.WriteLine(count) ;
		}

		/// <summary>
		/// PROBLEM 64.
		/// All square roots are periodic when written as continued fractions and can be written in the form:
		/// Exactly four continued fractions, for N < 13, have an odd period.
		/// How many continued fractions for N < 10000 have an odd period?
		/// </summary>
		public static void p064_OddPeriodSquareRoots()
		{
			//SEE: https://en.wikipedia.org/wiki/Periodic_continued_fraction for algorithm.

			//S => initial number
			//m => 0
			//d => 1
			//a => |root of S| (a number when squared is less than S)

			double m, d, a = 0;
			double count = 0;
			List<double> a_values = new List<double>(50);

			for ( int S = 2; S < 10000; S++ )
			{
				double root_S = Math.Sqrt(S);
				if (root_S.ToString().Contains('.') )//if (irrational) square root
				{
					m = 0;//default
					d = 1;//default
					a = ( int ) root_S;
					
					double a1 = a;//save first a

					//find next m, d, a
					while(a != a1 * 2 )//stop when current (a) is twice the first value of (a)
					{
						m = (d * a) - m;
						d = ( S - (m * m)) / d;
						a = (int)(( a1 + m ) / d);

						a_values.Add(a);
					}

					//count odd terms in list
					count = a_values.Count % 2 != 0 ? count + 1 : count;
					a_values.Clear();
				}
			}
			Console.WriteLine($"{count} continued fractions have an odd period");
		}

		/// <summary>
		/// PROBLEM 65.
		/// Find the sum of digits in the numerator of the 100th convergent of the continued fraction for e.
		/// </summary>
		public static void p065_ConvergentsOfE()
		{
			List<BigInteger> e_conv = new List<BigInteger>(100);

			e_conv.Add(2);
			e_conv.Add(1);

			int n = 2;
			e_conv.Add(n);

			//get first 100 convergents of e, 
			//e convergents follows this pattern ==> 2,1,2,1,1,4,1,1,6,1,1,8...
			while ( e_conv.Count <= 100 )
			{
				e_conv.Add(1);
				e_conv.Add(1);
				e_conv.Add(n + 2);
				n += 2;
			}

			//compute values of continued fractions of e
			//this algorithm starts from the last part of the continued fraction and ripples back up.

			BigInteger numerator = 1 / e_conv[ 99 ] + e_conv[ 98 ];
			BigInteger denomenator = 1;
			BigInteger prev_numerator = numerator;

			for ( int i = 97; i >= 0; i-- )
			{
				numerator = numerator * e_conv[i] + denomenator; // prev numerator x i-th convergent (next convergent) + prev denomenator
				denomenator = prev_numerator;
				prev_numerator = numerator;
			}

			Console.WriteLine($"100th convergent of e, {numerator} / {denomenator} ==> {numerator.ToString().ToCharArray().Sum(a => int.Parse(a.ToString()))}");
		}
	}

}


